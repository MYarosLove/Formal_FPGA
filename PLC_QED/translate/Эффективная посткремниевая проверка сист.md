Эффективная посткремниевая проверка систем-на-кристалле с помощью быстрого обнаружения ошибок
Effective Post-Silicon Validation of System-on-Chips Using Quick Error Detection

В данной статье представлена методика быстрого обнаружения ошибок (Quick Error Detection, QED) для систематического создания семейств посткремниевых тестов проверки, которые быстро обнаруживают ошибки в процессорных ядрах и неосновных компонентах (контроллерах кэша, контроллерах памяти и сетях межсоединений на кристалле) многоядерных систем на кристалле (SoC). Такое быстрое обнаружение крайне важно, поскольку длительная задержка обнаружения ошибок - время, проходящее между возникновением ошибки, вызванной багом, и ее проявлением в виде наблюдаемого сбоя - сильно ограничивает эффективность традиционных подходов к посткремниевой валидации. QED может быть реализована полностью программно, без каких-либо аппаратных модификаций. Таким образом, он легко применим к существующим конструкциям. Результаты, полученные на нескольких аппаратных платформах, включая Intel CoreTM i7 SoC и современную коммерческую многоядерную SoC, а также результаты моделирования с использованием OpenSPARC T2-подобной многоядерной SoC со сценариями ошибок коммерческих многоядерных SoC, демонстрируют:
1) время обнаружения ошибок в тестах посткремниевой проверки может быть очень большим, вплоть до миллиардов тактов, особенно для ошибок в неосновных компонентах; 
2) QED сокращает время обнаружения ошибок на девять порядков до всего нескольких сотен тактов для большинства сценариев ошибок; и 
3) QED позволяет увеличить покрытие ошибок до четырех раз.
Индексные термины - электрические ошибки, логические ошибки, посткремниевая валидация, кремниевая отладка, верификация.

I. ВВЕДЕНИЕ 
В ходе посткремниевой валидации изготовленные интегральные схемы (ИС) тестируются в реальных системных средах с целью обнаружения и устранения недостатков (ошибок) конструкции. Ошибки проектирования можно разделить на две категории. 
1) Логические ошибки, которые вызваны ошибками проектирования. Логические ошибки включают в себя неправильную аппаратную реализацию или неправильное взаимодействие между аппаратной реализацией и низкоуровневым системным программным обеспечением (например, микропрограммой). 
2) Электрические ошибки, которые вызваны тонкими взаимодействиями между конструкцией и ее электрическим состоянием. Примеры D включают целостность сигнала (перекрестные помехи и шум источника питания), тепловые эффекты и вариации процесса. Электрические ошибки часто проявляются при определенных условиях эксплуатации, например, при напряжении, частоте и температурных углах [51].
Посткремниевая валидация крайне важна, поскольку одной предварительной верификации недостаточно. Традиционная предварительная верификация слишком медленная и часто не способна обнаружить электрические ошибки, которые появляются только после изготовления ИС [51]. Однако существующие подходы к посткремниевой проверке носят специальный характер, например, вставка различных структур проектирования для отладки (DfD) [2], [62], основанных на эвристике [2], [33], [37]. Сообщается, что затраты на посткремниевую валидацию растут [32]. Кроме того, массовая интеграция разнообразных компонентов в сложные системы-на-кристалле (SoC), состоящие из нескольких процессорных ядер, сопроцессоров/ускорителей (например, для графики или криптографии) и неосновных компонентов (также называемых компонентами гнезда или северного моста), значительно усугубляет проблемы посткремниевой валидации [3], [42], [57]. Под неосновными компонентами понимаются компоненты в SoC, которые не являются ни процессорными ядрами, ни сопроцессорами. Примерами неосновных компонентов являются контроллеры кэша, контроллеры памяти и сети межсоединений на кристалле.
Посткремниевая валидация включает в себя три этапа.
1) Обнаружение ошибки путем применения соответствующих стимулов.
2) Локализация/корневая причина ошибки.
3) Исправление ошибки с помощью программных патчей, редактирования схемы или перевыпуска микросхемы.
Усилия по локализации/корневой причине ошибок по результатам наблюдаемых сбоев часто доминируют над затратами на посткремниевую валидацию [2], [5], [30]. Посткремниевая валидация затруднена, поскольку большинство существующих методов локализации/корневых причин ошибок опираются на: 
1) моделирование на уровне системы для получения ожидаемого или "золотого" отклика системы и 
2) воспроизведение сбоя на уровне системы, что предполагает возврат системы в состояние без ошибок и повторный запуск системы с точными входными стимулами (например, инструкциями теста проверки, входами теста проверки, условиями работы, такими как напряжение, температура и частота, и прерываниями) для воспроизведения сбоя. Однако моделирование на порядки медленнее, чем реальный кремний [47], а воспроизведение сбоев затруднено из-за эффектов Гейзенбага [23], асинхронных входов/выходов и доменов с несколькими тактовыми частотами.
Эти проблемы еще больше усугубляются длительными задержками обнаружения ошибок. Задержка обнаружения ошибок определяется как время, прошедшее между возникновением ошибки из-за бага и ее проявлением в виде наблюдаемого сбоя. Ошибки с задержкой обнаружения ошибок более нескольких тысяч тактов представляют собой очень сложную задачу, поскольку для их отладки крайне сложно проследить слишком большой исторический путь [53].

В данной статье представлена методика быстрого обнаружения ошибок (Quick Error Detection, QED), которая систематически преобразует существующие тесты посткремниевой валидации в новые тесты семейства QED с чрезвычайно коротким временем обнаружения ошибок и улучшенным покрытием. Тесты семейства QED направлены на поиск логических и электрических ошибок в процессорных ядрах, а также ошибок в неосновных компонентах. В этой статье мы демонстрируем эффективность QED для выявления ошибок в контроллерах кэша, памяти и сетях межсоединений на кристалле в дополнение к ошибкам в процессорных ядрах.
Основной вклад данной работы заключается в следующем.
1) Мы представляем подробное описание тестов семейства QED. Тесты семейства QED - это семейство тестов QED. Каждый QED-тест в семействе создается путем применения к исходному тесту набора QED-преобразований, а также определенных значений соответствующих параметров QED-преобразований. Выбор набора преобразований зависит от целевого компонента SoC (ядра процессора или неосновные компоненты). Параметры преобразования QED обеспечивают систематический способ компромисса между задержкой обнаружения ошибок и интрузивностью. Здесь под интрузивностью понимаются ситуации, когда оригинальный тест способен обнаружить ошибку, которая больше не обнаруживается тестами, преобразованными в QED.
2) Используя современную коммерческую многоядерную аппаратную платформу SoC, мы демонстрируем способность тестов семейства QED систематически корректировать компромисс между задержкой обнаружения ошибок и интрузивностью для реальной сложной логической ошибки.
3) Мы представляем результаты, полученные на нескольких аппаратных платформах, а также результаты моделирования с использованием реалистичных сценариев, демонстрирующие эффективность тестов семейства QED в улучшении задержек обнаружения ошибок на девять порядков, а покрытия - в четыре раза.
В наших предыдущих работах [28], [36] была представлена методика QED, а также список сценариев ошибок, полученных путем сбора и анализа "трудных" ошибок из баз данных ошибок коммерческих многоядерных SoC. Данная работа расширяет наши предыдущие работы следующим образом.
1) Мы подробно представляем тесты семейства QED.
2) Мы подкрепляем результаты, полученные в [28] и [36], более подробными аппаратными результатами (включая новые результаты по логическим ошибкам на аппаратной платформе) и обширными результатами моделирования с использованием OpenSPARC T2-подобной SoC [48].
Остальная часть данной работы организована следующим образом. В разделе II представлен список сценариев ошибок, полученных в результате анализа сообщений об ошибках нескольких современных коммерческих многоядерных SoC. В разделе III мы показываем, как традиционные посткремниевые тесты проверки могут приводить к очень большим задержкам обнаружения ошибок, а также вносить излишнюю интрузивность. В разделе IV представлена наша методика систематического создания тестов семейства QED для посткремниевой валидации. В разделе V мы приводим пример чрезвычайно сложной логической ошибки в современной коммерческой многоядерной аппаратной платформе SoC. В разделах VI и VII представлены результаты моделирования на многоядерной SoC OpenSPARC T2like и экспериментальные результаты на аппаратной платформе Intel CoreTM i7. В разделе VIII обсуждается связанная работа, а в разделе IX приводится заключение.

II. СЦЕНАРИИ РАБОТЫ ОШИБОК
Для продвижения исследований в области посткремниевой валидации очень важно иметь список сценариев ошибок, которые исследователи могут использовать для понимания ограничений существующих методов и оценки новых подходов. Для достижения этой цели мы составили список реалистичных сценариев ошибок, проанализировав сообщения об ошибках (в основном логических) "трудных" ошибок (т. е. ошибок, на отладку которых уходило очень много времени, как указывалось в сообщениях об ошибках), которые встречались в нескольких современных коммерческих многоядерных SoC.
Мы провели обширный анализ сообщений об ошибках и тесно сотрудничали с командами проверки, чтобы абстрагировать описания ошибок в сценарии, используя высокоуровневые описания и удаляя детали, специфичные для конкретного продукта. В результате несколько реальных ошибок были абстрагированы в один сценарий. Каждый сценарий ошибки состоит из критерия активации ошибки [Таблица I(a)] и эффекта ошибки [Таблица I(b)].
Критерий активации ошибки - это набор условий, которые должны быть выполнены для активации сценария ошибки. В таблице I(a) критерии 1-4 соответствуют ошибкам внутри контроллеров кэша, пятый критерий - ошибкам внутри контроллеров кэша, контроллеров памяти и сетей межсоединений на кристалле, а критерии 6-7 - ошибкам внутри процессорных ядер. Восьмой критерий активации соответствует сценариям, в которых ошибка активируется из-за случайного внешнего (асинхронного) события, например, внешнего прерывания, генерируемого при нажатии пользователем кнопки. Такие асинхронные события трудно уловить в среде моделирования (например, сложно смоделировать случайный ввод пользователя), поэтому мы абстрагировали этот критерий активации как случайно выбранный тактовый цикл, поскольку эти асинхронные события кажутся случайными для моделируемой системы.

Поскольку мы абстрагировали критерии активации от "неофициальных" сообщений об ошибках, возможно, что все условия активации не были полностью отражены. Для критериев активации 1-5 и 7 мы включили положительный целочисленный параметр X, который настраивается для создания семейства критериев активации ошибок из одного критерия активации ошибок. Минимальное значение, которое может принимать X, равно 2 (т. е. две операции хранения или загрузки за два такта; или две инструкции ветвления за два такта), но максимального значения для X нет.
Эффект ошибки означает неправильное поведение, возникающее в результате ее активации. В таблице I(b) эффекты A-E соответствуют ошибкам в контроллерах кэша, эффект F - ошибкам в контроллерах памяти, эффект G - ошибкам в сетях межсоединений, а эффекты H-J - ошибкам в процессорных ядрах. Эффект D имеет положительный целочисленный параметр Y, который может быть настроен для создания семейства эффектов. Минимальное значение, которое может принимать Y, равно 1 (т. е. задержка на один такт), а максимального значения для Y не существует.
Описания в таблицах I(a) и (b) позволяют нам реализовать каждый сценарий ошибки с помощью RTL или микроархитектурных симуляторов (подробности в разделе VI). Можно создавать семейства сценариев ошибок, изменяя параметры X и Y в таблицах I(a) и (b). Например, сопряжение критерия активации ошибки два, используя X = 2, с эффектом ошибки A приводит к сценарию ошибки 2A.
Несмотря на продолжающуюся работу над пониманием поведения электрических ошибок [21], [41], не существует единого мнения о том, что представляет собой точная модель логических ошибок [29]. Ранее исследователи анализировали логические ошибки, найденные в исследовательских микросхемах, учебных проектах и страницах с ошибками [15], [17], [18], [26], [59], [61]. Сценарии ошибок, приведенные в таблицах I(a) и (b), включают в себя ошибки из работ [17], [18], [26] и [61]. Сложно сравнивать ошибки в [15] и [59] с ошибками в таблице I(a) и (b). Это связано с тем, что в [15] приводятся примеры ошибок, специфичных для RTL, а в [59] основное внимание уделяется анализу первопричин, зависящих от реализации, например, отсутствующих входов и неправильных источников сигналов. В таблице II приведены сценарии обнаружения ошибок и более ранние попытки сбора логических ошибок.

III. ПРОБЛЕМА ДЛИТЕЛЬНОЙ ЗАДЕРЖКИ ОБНАРУЖЕНИЯ ОШИБОК
Во время посткремниевой проверки для обнаружения ошибок на изготовленных ИС проводятся различные тесты, такие как тесты случайных инструкций, тесты, ориентированные на конкретную архитектуру, трассировка инструкций и приложения для конечных пользователей [3], [32]. Учитывая длительное время выполнения таких тестов, как правило, сложно проводить их на этапе, предшествующем разработке кремния. Мы приводим пример на рис. 1 (основанный на сценарии ошибки 3C), чтобы проиллюстрировать длительные задержки обнаружения ошибок, а также навязчивость, с которой могут столкнуться традиционные посткремниевые тесты проверки. Пример, показанный на рис. 1, относится к реальной ошибке, обнаруженной в ходе посткремниевой проверки современной коммерческой многоядерной SoC. Рассмотрим многоядерную SoC, в которой каждое процессорное ядро может выполнять одну инструкцию за тактовый цикл, и каждое процессорное ядро имеет собственный кэш L1 с политикой записи [25] (на рис. 1 не показан). В SoC имеется общий кэш L2, использующий политику write-through и write-allocate [25]. Ниже показан сценарий ошибки 3C с X = 2.

Сценарий ошибки 3C с X = 2 активируется только в том случае, если в течение двух тактов в соседних строках кэша выполняются две операции сохранения. Поэтому, как показано на рис. 1(a), когда ядро 3 выполняет операцию сохранения в ячейку памяти A с последующим сохранением в ячейку памяти B за 2 такта, активируется сценарий ошибки 3C. При выполнении операции сохранения в ячейку памяти B, если B еще не кэширована, для B необходимо выделить новую строку кэша в общем кэше (т. е. контроллер кэша должен выбрать свободную строку кэша для ячейки памяти B или вытеснить существующую строку кэша, если свободная строка кэша недоступна). Однако из-за ошибки сценария 3C новая строка кэша не выделяется для B. Вместо этого ошибочно используется существующая строка кэша (т. е. такая, которая кэширует значение произвольной ячейки памяти, в данном примере это строка кэша, соответствующая некоторой произвольной ячейке памяти C). Операция сохранения ошибочно перезаписывает существующую строку кэша, кэширующую ячейку памяти C, повреждает кэшированное значение и помечает его как измененное. Обратите внимание, что благодаря политике записи через общий кэш, значение B корректно сохраняется в основной памяти.
Спустя очень долгое время Core 7 загружает из общего кэша поврежденное значение, соответствующее ячейке памяти C (поскольку строка кэша находится в измененном состоянии в общем кэше), и использует это поврежденное значение в своих вычислениях. Как следствие, Core 7 выдает неверные результаты. Как показано на рис. 1(a), тесты, основанные на проверке конечных результатов, которые проверяют ожидаемые выходные значения по завершении теста, приводят к очень большим задержкам обнаружения ошибок.

Как показано на рис. 1(b), поврежденное значение, считанное ядром 7, может привести к livelock/deadlock при использовании кода, выполняющего блокировку. Техники обнаружения блокировок/неблокировок [7], [12] в данном примере не позволяют сократить время обнаружения ошибки, поскольку время обнаружения ошибки уже очень велико, когда возникает блокировка (т. е. задолго после того, как повреждено кэшированное значение, соответствующее ячейке памяти C).

[Рис. 1. Примеры длительной задержки обнаружения ошибок и интрузивности традиционных посткремниевых тестов проверки. (a) Проверки конечных результатов с длительным временем обнаружения ошибок. (b) Обнаружение тупиковых ситуаций с большим временем обнаружения ошибок. (c) Тест самопроверки с большой задержкой обнаружения ошибок. (d) Тест самопроверки с чрезмерной навязчивостью. (e) Тест на считывание данных из магазина с большим временем обнаружения ошибок. (f) Тест обратного считывания из магазина с чрезмерной навязчивостью].

Тесты самопроверки, направленные на поиск ошибок внутри процессорных ядер, недостаточны для уменьшения времени задержки обнаружения ошибок, а также могут быть чрезмерно навязчивыми. Такие тесты проверяют результаты выполнения инструкций, вставляя инструкции самопроверки, которые сравнивают результаты с золотой моделью (т. е. с результатами моделирования) [4] или с результатами других инструкций, выполняемых на процессорных ядрах [52], [63].
На рис. 1(c) показан пример, когда самопроверяющий тест обнаруживает ошибку с очень большой задержкой обнаружения ошибки. Поскольку ошибка повреждает только значение кэша, соответствующее произвольной ячейке памяти C в общем кэше, самопроверка Core 3 не обнаруживает ошибку при проверке ячеек памяти A и B (поскольку обе они корректны). Пройдет очень много времени, прежде чем Core 7 выполнит загрузку из ячейки памяти C и обнаружит ошибку.
Тесты самопроверки также могут вносить излишнюю навязчивость, например, вставляя инструкцию проверки между инструкциями сохранения в ячейку памяти A и сохранения в ячейку памяти B [рис. 1(d)]. Это нарушает критерий активации двух сохранений в соседние строки кэша в течение двух тактов. Таким образом, ошибка не активируется и не может быть обнаружена.
Другой вариант самопроверки, называемый тестом чтения магазина [рис. 1(e)], выполняет операцию загрузки на том же ядре, которое выполнило операцию сохранения (в данном случае ядро 3), чтобы проверить, совпадает ли загруженное значение с сохраненным. Как показано на рис. 1(e), задержка обнаружения ошибки все еще очень велика, поскольку ни ячейки памяти A, ни B не повреждены. Проходит очень много времени, прежде чем ядро 7 выполнит загрузку из ячейки памяти C и обнаружит ошибку.

Как и на рис. 1(d), тест на чтение из хранилища также может быть навязчивым. Например, как показано на рис. 1(f), такой тест может вставить инструкции загрузки и проверки между двумя операциями сохранения; в результате критерий активации может быть нарушен, и ошибка не будет активирована и обнаружена.
QED преодолевает проблему длительного времени ожидания обнаружения ошибок, создавая тесты, которые быстро обнаруживают ошибки и одновременно улучшают покрытие. Тесты семейства QED также предоставляют систематический способ настройки интрузивности (с компромиссом по сравнению с задержкой обнаружения ошибок). Кроме того, тесты семейства QED не требуют моделирования для получения ожидаемых (т. е. золотых) результатов. В таблице III приведено качественное сравнение традиционных тестов посткремниевой валидации с тестами семейства QED (подробности в разделе IV).
Как показано в таблице III, в ситуациях, когда доступен только двоичный исполняемый файл теста, такие методы, как обнаружение тупиковых ситуаций, тесты самопроверки, тесты чтения из магазина и тесты семейства QED, могут потребовать моделирования для получения целевых адресов инструкций косвенного ветвления (т. е. инструкций ветвления, где целевой адрес хранится в регистре). Это необходимо, так как эти методы вставляют в середину теста дополнительные инструкции проверки, которые могут вытеснить адреса существующих инструкций в тесте. Поэтому целевые адреса инструкций ветвления должны быть изменены, чтобы ветвление происходило по новым адресам (после вставки проверочных инструкций). Пример показан на рис. 2. На рис. 2(a) показаны адреса и инструкции в исходном тесте. Оригинальный тест содержит инструкцию косвенного ветвления по адресу 0x0004, которая ветвится на инструкцию SUB по целевому адресу 0x000C (целевой адрес хранится в регистре R1). Однако после вставки инструкции проверки по адресу 0x0004 на рис. 2(b) адрес инструкции SUB смещается на 0x0010. Поэтому инструкция косвенного ветвления по адресу 0x0008 должна ветвиться на адрес 0x0010 (вместо адреса 0x000C). Чтобы определить целевой адрес инструкции косвенного ветвления, может потребоваться моделирование для определения значения R1 в момент выполнения инструкции косвенного ветвления. 

Это не требуется для инструкций прямого ветвления, поскольку целевой адрес инструкции прямого ветвления закодирован в самой инструкции и может быть легко идентифицирован при ее дизассемблировании. Это также не требуется, если техники применяются на уровне исходного кода (C или ассемблера), поскольку целевые адреса известны по меткам в исходном коде. Наконец, это может не потребоваться при проверке конечного результата, если проверочные инструкции добавляются только в конце исходного теста (таким образом, существующие инструкции в тесте не вытесняются проверочными инструкциями).

IV. БЫСТРОЕ ОБНАРУЖЕНИЕ ОШИБОК
При наличии теста для посткремниевой проверки (в данной статье именуемого "оригинальным" тестом) и целевого ограничения на время обнаружения ошибок (выраженного в количестве тактов), QED систематически преобразует оригинальные тесты в новые QED-тесты с помощью различных QED-преобразований. Полученные тесты QED имеют ограниченные задержки обнаружения ошибок. Целевое ограничение на время обнаружения ошибок определяется используемой техникой локализации ошибок (например, буферами трассировки или моделированием). В общем случае задержка обнаружения ошибок должна быть меньше 1 000 циклов, поскольку буферы трассировки записывают порядка 1 000 циклов истории [2], [49]. Кроме того, если имеются ограничения на навязчивость (например, если априори известно, что определенная последовательность инструкций ветвления или загрузки/хранения имеет высокую вероятность активации ошибок), такие ограничения могут быть предоставлены (например, в виде комментариев в тестовых инструкциях), чтобы преобразования QED не изменяли последовательность и не вносили чрезмерной навязчивости. Однако если такие ограничения интрузивности недоступны, интрузивность можно систематически регулировать с помощью параметров QED-преобразования (подробности в разделе IV-D).
Из одного исходного теста можно создать семейство QED-тестов (называемых тестами семейства QED), выбрав различные QED-преобразования (подробности в разделах IV-A-C) и параметры QED-преобразования (подробности в разделе IV-D) для каждого теста в семействе. Каждый из тестов семейства может иметь различные компромиссы между задержкой обнаружения ошибок, степенью навязчивости и компонентами SoC, на которые он нацелен (т. е. процессорные ядра против неосновных компонентов).
Хотя представленные здесь преобразования EDDI-V, CFCSS-V, CFTSS-V и PLC только для программных QED вдохновлены методами программно-реализованной аппаратной отказоустойчивости (SIHFT) [39] из отказоустойчивых вычислений, существуют важные различия между преобразованиями для посткремниевой валидации и преобразованиями для отказоустойчивых вычислений.
1) При посткремниевой валидации уменьшение времени задержки обнаружения ошибок чрезвычайно важно, поскольку время отладки, а не время выполнения теста является основным узким местом [30]. Поэтому некоторое превышение времени выполнения теста может быть приемлемым при посткремниевой проверке, если задержка обнаружения ошибок значительно уменьшена. Это связано с тем, что некоторое превышение времени выполнения теста (например, порядка нескольких минут или часов) при значительном сокращении времени обнаружения ошибок может привести к значительному увеличению времени отладки (например, порядка нескольких дней).
2) Преобразования для посткремниевых проверочных тестов не должны вызывать чрезмерной навязчивости, которая может ухудшить покрытие посткремниевых проверочных тестов. Например, как показано на примере ошибки в разделе III, если преобразование приводит к тому, что тест больше не активирует ошибку, то ошибка не может быть обнаружена и покрытие теста ухудшается. Это не является основной проблемой в отказоустойчивых вычислениях, особенно если речь идет о преходящих ошибках.
3) При посткремниевой валидации входные данные тестов могут быть известны заранее [9]. Это дает уникальную возможность оптимизировать преобразования QED для соответствующих тестовых входов, чтобы улучшить задержку обнаружения ошибок и снизить интрузивность. Например, если априори известно количество итераций, которые выполнит цикл, его можно развернуть, чтобы удовлетворить параметры QED-преобразования для задержки обнаружения ошибок и интрузивности (подробности в разделе IV-D).

В разделах IV-A-C представлены четыре программных преобразования QED: Обнаружение ошибок с помощью:
1. дублирования инструкций для валидации (EDDI-V), 
2. проактивная загрузка и проверка (PLC), 
3. проверка потока управления с помощью программных подписей для валидации (CFCSS-V) и 
4. отслеживание потока управления с помощью программных подписей для валидации (CFTSS-V). 

Эти программные преобразования QED не требуют никаких аппаратных модификаций и легко применимы к существующим потокам посткремниевой валидации. QED также может быть дополнен небольшой аппаратной поддержкой (подробности в [28]). В разделе IV-D представлены подробные сведения о параметрах преобразования QED - Inst_min и Inst_max. Как было сказано выше, из одного исходного теста можно создать несколько тестов семейства QED. Например, из исходного теста T можно создать следующие тесты семейства QED: T_eddiv, T_cfcssv, T_cftssv и T_plc, могут быть созданы путем преобразования T с помощью преобразований EDDI-V, CFCSS-V, CFTSS-V или PLC, соответственно. Кроме того, для создания одного теста семейства QED можно использовать несколько преобразований QED. Например, T может быть преобразован с помощью преобразований EDDI-V и CFCSS-V для создания T_eddiv_cfcssv, или T может быть преобразован с помощью преобразований CFTSS-V и PLC для создания T_cftssv_plc. Для каждого из тестов T_eddiv, T_cfcssv, T_cftssv, T_plc, T_eddiv_cfcssv, T_cftssv_plc можно выбрать диапазон значений параметров QED-преобразования Inst_min и Inst_max (подробности в разделе IV-D) и изменить "окно" для QED-преобразований (подробности в разделе IV-D), чтобы создать несколько тестов семейства QED. Пример создания тестов семейства QED из одного исходного теста T показан на рис. 3. Используются преобразования EDDI-V, CFCSS-V, CFTSS-V, PLC, EDDI-V + CFCSS-V и CFTSS-V + PLC. Для каждого преобразования мы выбираем диапазон значений для Inst_min, от Inst_min = 1 до Inst_min = 1 000, и диапазон значений для Inst_max, от Inst_max = 1 до Inst_max = 1 000, для создания тестов семейства QED. Мы также варьируем окно для каждого теста в семействе. 
A. Обнаружение ошибок с использованием дублирования инструкций для проверки (EDDI-V) Как показано в разделе III, посткремниевые проверочные тесты могут приводить к чрезвычайно большим задержкам обнаружения ошибок. Кроме того, такие тесты могут привести к чрезмерной навязчивости, что может негативно сказаться на покрытии тестами. В отличие от этого, EDDI-V (расширяющая технику EDDI, используемую в отказоустойчивых вычислениях [44]) ограничивает время обнаружения ошибок (подробности в разделе IV-D) для ошибок, возникающих внутри процессорных ядер, и обеспечивает возможность настройки степени интрузивности (подробности в разделе IV-D).
EDDI-V реализуется путем резервирования половины пространства регистров и памяти для инструкций из оригинального теста (в данной статье они называются "оригинальными"), а другая половина используется для дублированных инструкций, созданных в результате преобразования EDDI-V (подробности далее). Регистры и память для оригинальных и дублированных инструкций инициализируются одинаковыми значениями. Например, на рис. 4(a) оригинальный тест использует 16 регистров (r0-r15). Поэтому преобразование EDDI-V резервирует 16 регистров (r16-r31) и инициализирует их теми же значениями, что и r0-r15. В ситуациях, когда регистров недостаточно (т. е. если исходный тест должен использовать все доступные регистры), мы резервируем память для временного хранения значений регистров.1 Например, на рис. 4(b) исходный тест должен использовать все 32 регистра, доступные в системе (r0-r31). Поэтому преобразование EDDI-V резервирует два блока памяти, ORI[0..31] и DUP[0..31], для хранения оригинальных и дублированных значений регистров соответственно. Затем, как показано на рис. 4(b), перед выполнением блока оригинальных инструкций оригинальные значения регистров загружаются из блока памяти ORI обратно в регистры. После выполнения блока оригинальных инструкций значения регистров сохраняются обратно в блок памяти ORI. Затем в регистры загружаются дублированные значения регистров из блока памяти DUP. Дублированные инструкции, вставленные EDDI-V, выполняются, и значения регистров сохраняются обратно в блок памяти DUP.
Как показано на рис. 4, преобразование EDDI-V создает дублированные и проверочные инструкции. Для каждой арифметической, 1 Однако следует помнить о возможной навязчивости из-за дополнительных инструкций хранения и загрузки. логической, сдвига или перемещения в исходном тесте, создается соответствующая дублированная инструкция, которая работает с соответствующими дублированными регистрами, зарезервированными для EDDI-V (или дублированными значениями регистров, если регистры хранятся в памяти). Создается проверочная инструкция, которая сравнивает значения регистров назначения оригинальной и дублированной инструкций. Любое несовпадение при сравнении указывает на обнаружение ошибки. Аналогично, для каждой инструкции load и store создается соответствующая дублированная инструкция, которая работает с дублированными регистрами (или значениями регистров) и памятью, зарезервированной для EDDI-V. Создается инструкция проверки, которая сравнивает значения, сохраненные и загруженные оригинальной инструкцией, и соответствующие значения, сохраненные и загруженные дублированной инструкцией. Любое несоответствие при сравнении указывает на обнаружение ошибки. Частота вставки дублированных и проверочных инструкций в тест определяется параметрами преобразования QED Inst_min и Inst_max (подробности в разделе IV-D).
EDDI-V может быть усовершенствован с помощью методов разнообразия (например, основанных на принципах [45]), чтобы гарантировать, что инструкции, вставленные QED, выполняются иначе, чем инструкции из исходного теста. Такие методы разнообразия снижают вероятность того, что оригинальные и дублированные инструкции будут одинаково подвержены влиянию логических и электрических ошибок. Кроме того, наши результаты в разделах VI и VII также показывают, что EDDI-V по своей сути вносит временное разнообразие между выполнением оригинальных и дублированных инструкций, особенно для сложных логических и электрических ошибок.
B. PLC
PLC - это метод QED-преобразования, который ограничивает время обнаружения ошибок для ошибок внутри неосновных компонентов (например, контроллеров кэша, контроллеров памяти, сетей межсоединений). В отличие от EDDI-V, преобразование PLC не полагается только на (идентичное или различное) повторное выполнение инструкций в исходном тесте. Вместо этого оно вставляет специальные операции PLC с очень мелкой детализацией в пространстве памяти (и ввода-вывода), используя целевые инструкции. Эти операции PLC выполняют загрузку всех потоков, выполняющихся на всех ядрах процессора, из выбранного набора переменных и выполняют проверку самосогласованности этих переменных. Преобразование PLC совместимо с преобразованием EDDI-V; следовательно, ошибки внутри процессорных ядер также могут быть обнаружены с короткими задержками обнаружения ошибок.

В следующих подразделах мы представим подробный обзор шагов, необходимых для программной реализации преобразования PLC для многоядерных и многопоточных SoC, таких как OpenSPARC T2 SoC. Однако PLC может быть дополнительно усовершенствован за счет аппаратной поддержки (подробности выходят за рамки данной статьи).
1) Шаг 1 (инициализация): Учитывая исходный тест, мы сначала выполняем преобразование EDDI-V, чтобы связать задержки обнаружения ошибок для ошибок внутри процессорных ядер. Затем создается список PLC_List. Каждый элемент PLC_List состоит из кортежа <указатель исходной переменной, указатель переменной EDDI-V>. Указатель исходной переменной указывает на переменную в исходном тесте, выбранную для PLC. Стратегии выбора переменных для PLC обсуждаются позже. Указатель переменной EDDI-V указывает на соответствующую дублированную переменную, созданную EDDI-V (например, <&a, &a'> и <&b, &b'> на рис. 5). Значения указателей получаются либо через метки исходного кода (для статически выделенных переменных), либо через вызовы функции выделения памяти (для динамически выделенных переменных). Значения указателей используются для определения адресов памяти переменных при выполнении операций ПЛК.
Для многопоточных тестов все переменные, перечисленные в PLC_List, должны быть защищены от условий гонки между сохранением этих переменных одним потоком и операциями ПЛК (подробности позже) другим потоком. Такие условия гонки могут возникнуть из-за неожиданного чередования четырех операций: сохранения в исходную переменную в PLC_List, сохранения в соответствующую переменную EDDI-V, загрузки из исходной переменной в PLC_List и загрузки из соответствующей переменной EDDI-V. Это достигается путем блокировки пары исходной переменной и соответствующей переменной EDDI-V во время операций сохранения и загрузки этой пары (рис. 5).

2) Шаг 2 (вставка операций ПЛК): Преобразование ПЛК вставляет операции ПЛК в каждый поток, выполняемый на каждом процессорном ядре. Каждая операция PLC (рис. 6) выполняет следующие функции. Один раз выполняется итерация по всем кортежам в списке PLC_List. Для каждого кортежа в списке он блокирует кортеж и загружает значения, на которые указывают исходный указатель переменной и указатель переменной EDDI-V. После загрузки значений кортеж разблокируется. Затем два загруженных значения сравниваются друг с другом. В условиях отсутствия ошибок эти два значения должны полностью совпадать. Любое несовпадение указывает на обнаружение ошибки. Ошибки, затрагивающие сам PLC_List, могут быть быстро обнаружены, поскольку крайне маловероятно, что поврежденные адреса, соответствующие исходному указателю переменной и полям указателя переменной EDDI-V, будут содержать абсолютно одинаковые значения данных. 
Операции PLC вставляются с периодическими интервалами в каждый поток в каждом ядре процессора. Это необходимо, поскольку ошибки могут затрагивать различные пути между процессорными ядрами и неосновными компонентами. Кроме того, операции PLC проверяют все переменные в списке PLC_List, чтобы охватить ситуации, в которых некоторая произвольная переменная (не обязательно недавно измененная или используемая) затронута ошибкой. Например, операция сохранения/загрузки в одну переменную может вызвать ошибку, которая приведет к ошибке в другой переменной (например, пример, приведенный в разделе III). Интервалы, на которые операции ПЛК вставляются в тест, определяются параметрами преобразования QED Inst_min и Inst_max (подробности позже).
3) Стратегии выбора переменных для PLC: Существует несколько стратегий выбора переменных для включения в PLC_List.
1) Можно включить все переменные в данный тест. Однако в результате задержки обнаружения ошибок могут быть большими, особенно если ПЛК реализован программно. Это связано с тем, что операции ПЛК должны загружать и проверять все переменные в списке PLC_List, что может занять много времени.
2) Можно создать семейство тестов на основе исходного теста, где каждый тест в семействе выбирает только подмножество переменных (из исходного теста) для своего PLC_List. В этом случае один тест в семействе не сможет обнаружить все ошибки в системе. Однако наши результаты в разделе VI показывают, что все семейство тестов семейства QED на основе PLC очень эффективно в улучшении покрытия и сокращении времени обнаружения ошибок.
3) Если входные данные для теста известны заранее (что часто бывает при посткремниевой валидации [9]), можно выполнить профилирование для определения переменных с задержками store-toload или load-to-load (определяемыми как количество тактов, прошедших между инструкцией store/load в переменную и последующей загрузкой в ту же переменную), превышающими желаемые границы задержек обнаружения ошибок, и включить только эти переменные в PLC_List.
C. CFCSS-V и CFTSS-V
CFCSS-V и CFTSS-V - это два QED-преобразования, направленные на борьбу с ошибками, которые влияют на поток управления процессорного ядра. CFCSS-V вдохновлен CFCSS [46], используемым в отказоустойчивых вычислениях. Как и CFCSS, CFCSS-V проверяет поток управления тестовой программы во время выполнения по графу потока управления, построенному во время компиляции тестовой программы [46]. Однако основное различие между CFCSS для отказоустойчивых вычислений и CFCSS-V для посткремниевой валидации заключается в том, что CFCSS-V поддерживает конфигурируемость, позволяющую компенсировать задержку обнаружения ошибок интрузивностью. Для этого вместо проверки потока управления между базовыми блоками [46] CFCSS-V проверяет поток управления между "блоками инструкций", которые могут содержать произвольное количество инструкций, определяемое параметрами QED-преобразования Inst_min и Inst_max (подробности в разделе IV-D). Регулируя Inst_min и Inst_max, количество инструкций в "блоке инструкций" может варьироваться от одной инструкции (т. е. короткая задержка обнаружения ошибок, но высокая интрузивность) до нескольких базовых блоков (т. е. более длительная задержка обнаружения ошибок, но низкая интрузивность).
CFCSS-V реализуется путем разбиения исходного теста на "блоки инструкций", определяемые Inst_min и Inst_max. Каждому "блоку инструкций" присваивается уникальное целое число (т.е. программная сигнатура). Алгоритмы присвоения сигнатур можно найти в [38], [46] и [54]. Затем строится граф потока управления между блоками инструкций по алгоритму, представленному в [46]. Наконец, в начале каждого "блока инструкций" вставляется код, который сверяет поток управления во время выполнения с графом потока управления, используя технику, представленную в [46].

CFTSS-V - это вариант CFCSS-V, который отслеживает выполнение инструкций с помощью специальных программных сигнатур, вставленных в тестовый код, но не выполняет проверку потока управления. Преобразование CFTSS-V выполняется путем объявления глобальной переменной CFTSS_V_SIGNATURE, хранящейся в памяти и содержащей текущие сигнатуры программы во время выполнения. Затем инструкции в тесте делятся на "блоки инструкций", определяемые параметрами QED-преобразования Inst_min и Inst_max (подробности в разделе IV-D). Затем каждому "блоку инструкций" присваивается уникальное целое число (т. е. программная сигнатура). Алгоритм присвоения программной сигнатуры можно найти в [38], [46] и [54].
Затем преобразование CFTSS-V вставляет операции CFTSS-V в начало каждого "блока инструкций". Каждая операция CFTSS-V сохраняет назначенную программную сигнатуру "блока инструкций" в глобальной переменной CFTSS_V_SIGNATURE. На рис. 7 приведен псевдоассемблерный код для операции CFTSS-V. На рис. 7 [TEMP_VARIABLE] - это выделенная ячейка памяти, используемая для хранения сохраненного значения R1. Это необходимо, поскольку преобразование CFTSS-V не должно изменять значения регистров в исходном тесте. SOFTWARE_SIGNATURE - это уникальная программная подпись, присвоенная "блоку инструкций" с помощью алгоритма присвоения подписи, приведенного в [46], а [CFTSS_V_SIGNATURE] - это специально выделенная область памяти для хранения текущей подписи теста во время выполнения. При возникновении сбоя (например, livelock или deadlock) содержимое [CFTSS_V_SIGNATURE] используется для определения последнего "блока инструкций", который был выполнен процессорным ядром до сбоя.
D. Параметры преобразования QED: Inst_min и Inst_max
Преобразования QED поддерживают систематический компромисс между задержкой обнаружения ошибок и интрузивностью. Это достигается с помощью двух параметров преобразования QED: Inst_min и Inst_max, которые соответствуют минимальному и максимальному количеству исходных инструкций, выполняемых перед выполнением любых инструкций, вставленных QED-преобразованиями (Inst_min должен быть меньше или равен Inst_max по определению). Увеличение Inst_min уменьшает интрузивность, и наоборот. Уменьшение Inst_max уменьшает задержку обнаружения ошибок, и наоборот. Обратите внимание, что, в отличие от Inst_max, который всегда может быть удовлетворен, Inst_min является "мягким ограничением": хотя мы прилагаем все усилия, чтобы удовлетворить Inst_min, есть некоторые случаи, когда это невозможно. Например, Inst_min не может быть удовлетворено, если исходный код содержит меньше Inst_min инструкций. Более того, слишком большое Inst_min может ухудшить преимущества QED для покрытия. Например, если Inst_min слишком велик, ошибка, вызванная багом, может быть замаскирована до того, как ее обнаружит QED.
При посткремниевой валидации входные данные тестовой программы могут быть известны априори [9]. Поэтому мы можем использовать методы анализа кода, чтобы убедиться, что параметры преобразования QED Inst_min и Inst_max могут быть удовлетворены, даже если исходный тест содержит циклы, условные ветвления и примитивы синхронизации, такие как блокировки. Например, небольшой цикл может содержать меньше инструкций, чем требуется для Inst_min. В этом случае цикл разворачивается так, чтобы выполнялось несколько итераций без промежуточных ветвлений. Таким образом, можно построить более крупные блоки, содержащие больше инструкций, чем Inst_min. Аналогично, может оказаться невозможным разделить тело цикла, содержащее более Inst_max инструкций, на блоки, каждый из которых содержит менее Inst_max и более Inst_min инструкций. В этом случае цикл разворачивается до тех пор, пока не удастся разделить тело цикла на блоки инструкций, удовлетворяющие Inst_max и Inst_min. Для инструкций условного ветвления мы рассматриваем каждую ветвь (включая ветви любых вложенных инструкций условного ветвления) отдельно и разбиваем инструкции каждой ветви на блоки инструкций, удовлетворяющие как Inst_min, так и Inst_max. Для блокировок оригинальные и дублированные блоки кода заключаются в одинаковый набор инструкций блокировки и разблокировки.
Как показано на рис. 8, инструкции из исходного теста разбиваются на "блоки инструкций" (определяемые Inst_min и Inst_max). Задержка обнаружения ошибок ограничена суммой двух членов. 
1) Время, необходимое для выполнения блока исходных инструкций (т. е. ограниченное Inst_max). 
2) Время, необходимое для выполнения соответствующего блока QED (т. е. дублирования и проверки инструкций EDDI-V, операции PLC, CFCSS-V или CFTSS-V).

Это может значительно сократить время обнаружения ошибок по сравнению с исходным тестом, который может обнаружить ошибки только после видимого сбоя (например, сбоя программы) или с помощью своих исходных проверок (если таковые имеются, например, проверки конечных результатов, которые сравнивают фактические результаты работы программы с ожидаемыми), причем оба эти параметра могут быть неограниченными. Преобразования QED также создают семейство тестов (т. е. тесты семейства QED) из одного исходного теста путем систематического выбора различных Inst_min и Inst_max для каждого теста в семействе. Это обеспечивает систематический компромисс между задержкой обнаружения ошибок и степенью навязчивости.
Для выбранной пары Inst_min и Inst_max можно создать несколько тестов семейства QED, изменяя окно инструкций, входящих в "блок инструкций". Мы определяем окно как последовательность инструкций, объединенных в "блок инструкций". Например, на рис. 9 показаны три различных окна для Inst_min = Inst_max = 3. На рис. 9 каждый "блок инструкций" для тестов (a), (b) и (c) содержит три инструкции. Однако конкретные инструкции, которые группируются в окно, различны для всех трех тестов. Например, в тесте (a) в окно группируются инструкции {Инструкция 11, Инструкция 12, Инструкция 13}, в тесте (b) в окно группируются инструкции {Инструкция 12, Инструкция 13, Инструкция 14}, а в тесте (c) в окно группируются инструкции {Инструкция 13, Инструкция 14, Инструкция 15}.
E. Резюме и сравнение QED-преобразований
В предыдущих подразделах были представлены четыре программных QED-преобразования. В таблице IV представлено качественное сравнение представленных выше QED-преобразований, с акцентом на плюсы и минусы каждого преобразования и типы ошибок, на которые направлено каждое из преобразований.
V. КОНКРЕТНЫЙ ПРИМЕР: ЛОГИЧЕСКАЯ ОШИБКА В МНОГОЯДЕРНОМ ОБОРУДОВАНИИ SOC
В этом разделе мы приводим пример, демонстрирующий эффективность QED в обнаружении логических ошибок в сложной многоядерной аппаратной платформе SoC. SoC содержит шесть суперскалярных процессорных ядер вне порядка. Каждое ядро имеет собственные кэши L1 и L2. Процессорные ядра соединены между собой когерентной сетью межсоединений, которая также соединяет процессорные ядра с другими неосновными компонентами, такими как общие кэши L3, контроллеры памяти, сетевые контроллеры и контроллеры ввода-вывода. Название и номер модели SoC не указываются из соображений конфиденциальности. На рис. 10 показана фотография SoC в лаборатории проверки во время посткремниевой проверки.
В SoC обнаружена логическая ошибка, которую очень сложно отладить по следующим причинам (конкретные детали ошибки не раскрываются по соображениям конфиденциальности). 1) Ошибка не затрагивает никаких архитектурных состояний, то есть не изменяет никаких регистров или ячеек памяти. Единственным следствием ошибки является тупик процессорного ядра, т.е. процессорное ядро не будет выполнять никаких инструкций.
2) Изначально ошибка обнаруживалась только таймером таймаута длительностью в десятки секунд. Это соответствует задержке обнаружения ошибки порядка 15 миллиардов тактовых циклов.
3) Для активации ошибки требуется очень специфическая последовательность инструкций. Если тест будет модифицирован (например, путем усечения/удаления инструкций из теста или изменения инструкций в тесте), может возникнуть чрезмерная навязчивость, и тест не сможет активировать ошибку.
Нам не сообщили заранее конкретную последовательность инструкций, необходимую для активации этого бага. Мы получили оригинальный тест (в виде бинарного файла), который первоначально использовался для активации этого бага. На основе исходного теста мы систематически создавали тесты семейства QED, выбирая различные преобразования QED и систематически изменяя Inst_min для каждого теста в семействе. Преобразования QED не требуют никакой информации об ошибке, и при создании тестов семейства QED мы не использовали никаких деталей, специфичных для дизайна (например, микроархитектурную информацию). В следующих подразделах подробно описаны результаты тестов семейства QED, созданных с помощью преобразований CFCSS-V, CFTSS-V и EDDI-V. Тесты семейства QED на основе ПЛК не использовались, поскольку оригинальный тест не нацелен на неосновные компоненты.

A. Результаты тестов семейства CFCSS-V и CFTSS-V QED
Мы создали тесты семейства CFCSS-V и CFTSS-V QED, изменяя Inst_min, чтобы систематически корректировать компромисс между задержкой обнаружения ошибок и интрузивностью (определяемой тем, сохраняется ли тупиковая ситуация на ядре процессора). Мы начали с Inst_min = 1 000 инструкций (максимальная желаемая задержка обнаружения ошибок); для каждого теста семейства QED мы уменьшали Inst_min, чтобы улучшить задержку обнаружения ошибок (ценой возможного увеличения интрузивности). Для Inst_min ≤ 20 мы также варьировали "окна" преобразования (раздел IV-D), чтобы создать несколько тестов для каждого Inst_min. Затем мы запустили каждый тест семейства на платформе SoC, чтобы определить, сохраняется ли тупик в процессорном ядре при заданном Inst_min. Для Inst_min ≤ 20 ошибка считается активированной, если хотя бы один из тестов, созданных с помощью метода трансформации "окно" для данного значения Inst_min, активировал ошибку. Если возникал тупик, мы записывали "блок инструкций", который, по определению CFCSS-V или CFTSS-V, был последним блоком, выполненным процессорным ядром перед возникновением тупика.
Результаты представлены на рис. 11, где по горизонтальной оси отложено значение Inst_min, а по вертикальной - задержка обнаружения ошибки. Тесты семейства QED на базе CFTSS-V обнаружили ошибку в течение девяти инструкций после ее активации (что соответствует задержке обнаружения ошибок примерно в девять тактов). Это на девять порядков больше латентности обнаружения ошибок по сравнению с оригинальным тестом. Тесты семейства QED на базе CFCSS-V обнаруживают ошибку в течение 14 инструкций после активации. Это немного дольше, чем у тестов семейства QED на базе CFTSS-V, поскольку преобразование CFCSS-V вставляет в тест больше инструкций по сравнению с преобразованием CFTSS-V.
На рис. 11 показан систематический компромисс между задержкой обнаружения ошибок и интрузивностью с помощью Inst_min. Для этой ошибки преобразование CFTSS-V с Inst_min меньше девяти инструкций вносило чрезмерную интрузивность; поэтому ошибка не активируется и не обнаруживается, когда Inst_min меньше девяти инструкций. Для преобразования CFCSS-V Inst_min меньше 14 инструкций приводит к чрезмерной навязчивости. Корректировка Inst_min отличается от усечения тестовой программы (т. е. удаления инструкций из тестовой программы для уменьшения времени задержки обнаружения ошибки), поскольку усечение тестовой программы может привести к удалению инструкций, необходимых для активации ошибки. В отличие от этого, регулировка Inst_min не удаляет никаких инструкций и гарантирует, что тестовая программа по-прежнему содержит инструкции, необходимые для активации ошибки. 
В таблице V приведены данные о задержках обнаружения ошибок в оригинальном тесте и тестах семейства QED. Мы работали с командой проверки, чтобы убедиться, что тесты семейства QED действительно обнаружили сложный баг, о котором идет речь.
B. Результаты тестов семейства QED EDDI-V
Мы также провели эксперименты, чтобы оценить эффективность использования Inst_min для систематической настройки интрузивности преобразования EDDI-V. Отметим, что, поскольку данная ошибка не затрагивает регистры или ячейки памяти, тесты только EDDI-V не обнаруживают ее (поэтому задержки обнаружения ошибок не сообщаются). Однако мы все равно можем охарактеризовать навязчивость тестов, основанных только на EDDI-V, наблюдая, возникает ли тупик при заданном Inst_min.
Мы создали тесты семейства QED на основе EDDI-V, изменяя параметр Inst_min преобразования EDDI-V. Изменяя значения Inst_min, мы можем определить значения Inst_min, при которых сохраняется тупиковая ситуация в процессорном ядре. Мы начали с Inst_min = 1, которое имеет наибольшую навязчивость, но наименьшую задержку обнаружения ошибок, и увеличивали Inst_min на 1 для каждого теста в семействе (т. е. Inst_min = 1, 2, 3. . . .). Результаты представлены на рис. 12. Для каждого Inst_min ошибка считается активированной, если хотя бы один из тестов, созданных методом трансформации "окно" для данного значения Inst_min, активировал ошибку. Как показано на рис. 12, минимальное значение Inst_min, при котором еще сохраняется тупик, равно 17. Это значение больше, чем девять инструкций для CFTSS-V или 14 инструкций для теста семейства QED на основе CFCSS-V, поскольку преобразование EDDI-V вставляет в тест больше инструкций, что может привести к большей интрузивности. 

VI. РЕЗУЛЬТАТЫ МОДЕЛИРОВАНИЯ OPEN SPARC T2
Чтобы продемонстрировать эффективность QED для широкого спектра ошибок, мы оценили QED, смоделировав сценарии ошибок, описанные в разделе II, с помощью микроархитектурного симулятора. Мы использовали мультипроцессорный симулятор Multifacet (GEMS) [40] для моделирования OpenSPARC T2-подобной SoC [48], 500-миллионной транзисторной конструкции с восемью процессорными ядрами, 64 аппаратными потоками, частными кэшами данных и инструкций L1, межсоединениями на основе перемычек, восьмисторонним кэшем L2 с банками и протоколом когерентности кэша на основе каталогов, а также четырьмя контроллерами памяти (рис. 13).
Таблица I(a) и (b) вместе дают 80 различных классов ошибок (перекрестное произведение восьми критериев активации ошибок и десяти эффектов ошибок в таблице I(a) и (b)). Преобразованиям QED не требуется никакой информации о сценариях ошибок. Для каждого критерия активации с параметром X мы варьировали X от 2 до 1 000 тактов, чтобы создать семейство критериев активации. Мы ограничили минимальный диапазон развертки двумя тактовыми циклами, поскольку симулируемое процессорное ядро не может выполнить более двух инструкций загрузки, хранения или ветвления за один тактовый цикл [40]. Мы ограничили максимальный диапазон развертки X до 1 000 тактов, поскольку после X = 800 тактов количество раз, когда удовлетворяются критерии активации 1-5 и 7, существенно не меняется при увеличении X (100 % инструкций загрузки/хранения удовлетворяют критериям активации 1-5 и 100 % инструкций ветвления удовлетворяют критерию активации 7). Это дает в общей сложности девять различных значений X (т. е. X = 2, 5, 10, 20, 50, 100, 200, 500, 1 000 тактов, чтобы распределить значения X между 2 и 1 000). Для эффекта ошибки D мы варьировали Y (количество тактов задержки) от 1 такта до 1 000 тактов, чтобы создать семейство из десяти эффектов ошибки (т. е. Y = 1, 2, 5, 10, 20, 50, 100, 200, 500, 1 000 тактов для значений Y от 1 до 1 000). Это дает нам в общей сложности 19 различных эффектов ошибки (эффекты ошибки A, B, C, E, F, G, H, I и J плюс десять эффектов ошибки, возникающих в результате эффекта ошибки D при изменении Y). Мы выбрали максимальное значение Y равным 1 000 циклов, чтобы оно было значительно больше, чем максимальная задержка кэша (16 циклов в нашей системе). Для каждого значения X существует в общей сложности 152 различных сценария ошибки (т. е. перекрестное произведение восьми критериев активации ошибки и 19 ее эффектов). Таким образом, всего получается 1 368 сценариев ошибок. Преобразование QED является агностическим (т. е. не учитывающим специфику) по отношению к сценариям ошибок, а также агностическим по отношению к параметрам X и Y.
В данном разделе сценарии ошибок соответствуют логическим ошибкам, которые всегда присутствуют в системе (т. е. они не инжектируются). Для того чтобы логический баг вызвал эффект в системе, должен быть выполнен определенный набор критериев активации. Поэтому сценарии ошибок моделировались следующим образом: для каждого эксперимента моделировался только один сценарий ошибки. Для выбранного сценария мы модифицировали исходный код моделируемой системы, включив в него две дополнительные процедуры: одну, которая постоянно отслеживает критерий активации моделируемой системы, и вторую, которая вставляет эффект ошибки в систему (первоначально отключенную). Когда критерий активации выполняется, включается процедура, которая вставляет эффект жучка в систему, чтобы создать эффект жучка в системе. Поскольку критерий активации может быть удовлетворен несколько раз за время выполнения моделирования, эффект ошибки может быть вставлен также несколько раз (т. е. один раз за каждый раз, когда критерий активации удовлетворен), что соответствует поведению (логических) ошибок в реальных системах. Сценарий ошибки затрагивает все ядра, L2-кэш и контроллеры памяти (т. е. ни один конкретный компонент не был предварительно выбран).

Результаты приведены на рис. 14 и 15 для программ FFT, LU, RADIX и OCEAN из набора бенчмарков SPLASH-2 [64] и собственного промышленного теста посткремниевой проверки, направленного на устранение ошибок в памяти (подробности опущены в целях конфиденциальности). Мы провели анализ тестов SPLASH-2, подсчитав процентное соотношение различных инструкций в каждом тесте. Поскольку большинство сценариев ошибок в разделе II связаны с неосновными компонентами (которые взаимодействуют с ядрами процессора, используя только инструкции загрузки/хранения), мы подсчитали процент инструкций загрузки/хранения от общего числа инструкций для каждого из тестов в наборе бенчмарков SPLASH-2. Мы выбрали тесты с низким, средним и высоким процентом инструкций загрузки/хранения. В наборе бенчмарков SPLASH-2 есть тесты с процентом инструкций загрузки/хранения от 10 до 19 %. RADIX имеет максимальный процент инструкций загрузки/хранения (19%) из всех тестов набора. LU и OCEAN имеют средний процент инструкций загрузки/хранения (15 и 13 %). FFT имеет минимальный процент инструкций загрузки/хранения (10 %) среди всех тестов в наборе бенчмарков SPLASH-2. На рис. 14 вертикальные оси представляют собой абсолютный процент обнаруженных сценариев ошибок из раздела II (без нормировки на количество ошибок, обнаруженных тестами семейства QED), а горизонтальные оси - задержки обнаружения ошибок в тактах. На рис. 14 мы задали X = 10 тактов и Y = 100 тактов для сценариев ошибок, поскольку эти значения дают нам "близкое" представление (на нашей платформе моделирования) о "трудных" ошибках, найденных в базах данных ошибок. Однако, чтобы показать, что улучшения QEDs в задержках обнаружения ошибок и покрытии не зависят от параметров X и Y, мы также измерили задержки обнаружения ошибок и покрытие, изменяя параметры X и Y, которые представлены на рис. 15. На рис. 14 и 15 ограничения на время обнаружения ошибок и интрузивность заданы с помощью параметров преобразования QED (т. е. Inst_min = Inst_max = 10 строк исходного кода на языке C).
На рис. 15 вертикальные оси представляют задержки обнаружения ошибок в тактах. Горизонтальные оси представляют собой значения X для сценариев ошибок. На рис. 15 для каждого значения X имеется 152 сценария ошибок (полученных с использованием различных комбинаций: критериев активации ошибок, эффектов ошибок и параметра Y, как обсуждалось выше). На рис. 15 показаны минимальная, медианная (представленная квадратной точкой) и максимальная задержки обнаружения ошибок. Результаты на рис. 14 и 15 соответствуют восьмипоточным (по одному потоку на ядро) версиям тестов. 64-поточные версии тестов не использовались из-за низкой скорости моделирования и из-за того, что наш симулятор не позволяет точно моделировать системы с 64 аппаратными потоками [40]. На рис. 14 и 15 оригинальные тесты оснащены только "проверкой конечного результата". Поскольку входные данные этих тестов известны априори, можно рассчитать ожидаемые конечные результаты.
Для тестов семейства QED (PLC + EDDI-V) на рис. 14 и 15 мы выполнили преобразования QED на основе PLC и EDDI-V на уровне исходного кода C с Inst_min = Inst_max = 10 строк исходного кода C. Мы разделили все переменные кучи в исходном тесте на 1024 группы. Для этого мы собираем список, содержащий все переменные кучи (они известны априори, так как известны входные данные для тестов), и делим этот список на 1024 группы. В результате в семействе появляется 1024 отдельных теста, каждый из которых выполняет операции PLC только для переменных из соответствующей группы. Переменные регистра не включены в PLC, поскольку ошибки в этих переменных могут быть быстро обнаружены только с помощью EDDI-V. Каждый тест в семействе выполняется последовательно. Для каждого сценария ошибки задержка обнаружения ошибки, представленная на рис. 14 и 15, соответствует задержке обнаружения ошибки, когда сценарий ошибки был впервые обнаружен тестами семейства QED. Для промышленного тестирования существует единственный тест семейства QED, состоящий из всех переменных, выделенных в памяти. Поскольку этот тест нацелен только на ошибки в памяти, на рис. 14(e) и 15(e) рассматриваются только сценарии ошибок в памяти (т. е. критерии активации 1-5 в таблице I(a) и эффекты A-G в таблице I(b)). На рис. 14 и 15 также представлены результаты для тестов EDDI-V, полученные путем преобразования исходных тестов с использованием только преобразования EDDI-V в исходном коде на языке C.
В таблице VI показано время выполнения исходных тестов, тестов только с EDDI-V и тестов семейства QED с PLC и EDDI-V. Для каждой строки в таблице VI время выполнения, указанное в каждом столбце, нормировано на время выполнения исходного теста (т.е. второй столбец). Представленное время выполнения тестов семейства QED - это суммарное время выполнения всех тестов семейства (т. е. 1024 теста семейства для FFT, LU, RADIX, OCEAN и один тест семейства для промышленной проверки). Время выполнения тестов семейства QED значительно превышает время выполнения оригинальных тестов. В связи с этим возникает вопрос: являются ли значительные преимущества тестов семейства QED по покрытию (и задержке обнаружения ошибок) следствием использования проверочных инструкций QED или более длительного времени выполнения? Возможно, тесты семейства QED имеют больше возможностей для активации сценариев ошибок из-за более длительного времени выполнения, что приводит к улучшению покрытия и латентности обнаружения ошибок. Чтобы ответить на этот вопрос, мы провели контролируемый набор экспериментов. Для исходного теста мы создали версию теста, время выполнения которой примерно такое же, как у тестов семейства QED. Для этого мы сохранили большинство тестов семейства QED, но удалили код сообщения об ошибке, когда проверка EDDI-V или PLC обнаруживает ошибку. Эти тесты называются эквивалентными тестами времени выполнения (ERT-тестами). Задержка обнаружения ошибок и покрытие тестов ERT показаны на рис. 14 и 15. Тест ERT не был создан для промышленного теста валидации, поскольку время выполнения оригинального теста и так очень велико.
Из полученных результатов можно сделать следующие выводы.
Наблюдение 1: Посткремниевые тесты, созданные с помощью нашей методики QED, сокращают время обнаружения ошибок на несколько порядков для всех сценариев, описанных в разделе II. Задержки обнаружения ошибок оригинальных тестов могут быть очень большими: несколько миллионов или миллиардов циклов. Тесты EDDI-V, нацеленные только на ошибки в ядрах процессора, имеют большие задержки обнаружения ошибок для неядерных ошибок. В отличие от этого, тесты семейства QED с PLC и EDDI-V имеют задержки обнаружения ошибок всего в несколько сотен циклов для большинства сценариев. Сравнение с результатами ERT показывает, что эти преимущества связаны с операциями QED, а не с более длительным временем выполнения тестов семейства QED.
Наблюдение 2: Тесты для посткремниевой проверки, созданные с помощью нашей методики QED, продолжают обнаруживать сценарии ошибок, выявленные оригинальными тестами. Нет ни одного сценария ошибки, который был бы обнаружен оригинальными тестами (или только тестами EDDI-V, или тестами ERT), но не был бы обнаружен тестами семейства QED с EDDI-V и PLC. 
Наблюдение 3: тесты семейства QED с PLC и EDDI-V обнаруживают в два раза больше сценариев ошибок, которые в противном случае остались бы необнаруженными оригинальными тестами, тестами EDDI-V или тестами ERT. Наши эксперименты подтвердили, что каждый сценарий ошибки был активирован по крайней мере один раз оригинальными тестами, тестами семейства QED, тестами только EDDI-V и тестами ERT.
VII. АППАРАТНЫЕ РЕЗУЛЬТАТЫ I NTEL CORE I-7
На рис. 16 показана четырехъядерная аппаратная платформа Intel CoreTM i7, использованная для оценки QED. BIOS материнской платы DX58SO используется для изменения рабочего напряжения и частоты процессора. Для поддержания фиксированной температуры корпуса чипа используется разработанный на заказ терморегулятор. Отладочный инструмент, подключенный к отладочному порту системы, используется для контроля и наблюдения за состоянием системы (например, содержимое регистров и памяти, рабочее напряжение и частота).
A. Результаты задержки обнаружения ошибок
Мы провели эксперименты по внедрению ошибок, чтобы измерить время обнаружения ошибок в тестах QED. Сложность измерения задержек обнаружения ошибок в аппаратной платформе заключается в невозможности определить точный момент времени, когда происходит ошибка. Чтобы преодолеть эту проблему, мы создаем окно уязвимости, в течение которого условия устанавливаются таким образом, что могут возникнуть ошибки. Начало этого окна является нижней границей того момента, когда ошибка (если таковая возникнет) действительно произойдет, что позволяет нам получить задержку между инъекцией и обнаружением - время между началом окна уязвимости и обнаружением ошибки. Задержка между инъекцией и обнаружением является верхней границей (т. е. пессимистичной) для задержки обнаружения ошибки. Окно уязвимости создается с помощью инструмента отладки для временного перевода системы из состояния, в котором система работает без ошибок (т. е. надежное рабочее состояние), в состояние, в котором могут возникнуть ошибки (т. е. ненадежное рабочее состояние), и обратно. Любая ошибка должна произойти во время окна уязвимости, которое длится не более нескольких сотен миллионов циклов.

Мы определили условия, при которых система будет работать с ошибками и без них, изменяя значения частоты, напряжения и температуры. В нашей системе пара надежных и ненадежных условий работы (напряжение, частота) были выбраны как (1,02 В, 1,6 ГГц) и (1,02 В, 3,2 ГГц) соответственно, а температура корпуса была зафиксирована на 30◦ C. Надежные условия работы были выбраны с большим запасом по частоте, чтобы обеспечить безошибочную работу системы, а частота ненадежных условий работы была выбрана лишь немного выше частоты, которую процессор может надежно поддерживать при напряжении 1. Фиксируя напряжение на уровне 1,02 В и снижая частоту на один шаг 133 МГц ниже 3,2 ГГц, не более двух проверок QED выявили ошибку(и) во время каждого из 10 двухчасовых тестовых прогонов (с использованием теста Linpack, описанного ниже). Более того, при напряжении 1,02 В и двух шагах (т. е. 266 МГц) ниже 3,2 ГГц ошибок не было обнаружено за все время 10 двухчасовых тестовых прогонов.
Мы получили 75 значений задержки между инжекцией и обнаружением; распределения показаны на рис. 17. На рис. 17 вертикальная ось представляет собой процент обнаруженных ошибок. По соображениям конфиденциальности этот показатель нормирован на QED. Горизонтальная ось представляет собой задержки обнаружения ошибок. В качестве проверочного теста в данном эксперименте использован бенчмарк Linpack [19]. Тест Linpack, используемый в нашем эксперименте, выполняет главный цикл в течение двух часов, и в каждой итерации главного цикла выполняются одни и те же операции. Мы преобразовали исходную программу Linpack в QED-тест, выполнив преобразование EDDI-V на уровне исходного кода с Inst_min = Inst_max = 10 строк исходного кода.
На рис. 17 приведены результаты QED-теста с учетом QED-проверки. Результаты оригинального теста, показанные на рис. 17, были получены при игнорировании проверок QED и учете только проверок конечного результата оригинального теста. Это позволяет нам сравнить задержки между инъекциями и обнаружением, полученные только при использовании проверок конечных результатов, и задержки между инъекциями и обнаружением, полученные при использовании проверок QED, в отношении одной и той же ошибки (ошибок).
При использовании QED-тестов задержки между инъекцией и обнаружением очень короткие, от менее чем 1 000 тактов до ∼ 6 000 тактов, как показано на рис. 17 (фактические задержки обнаружения ошибок еще короче, поскольку задержка между инъекцией и обнаружением является лишь верхней границей). Для тестов QED 86 % задержек между инжекцией и обнаружением составляют менее 1 000 тактов. 24 % задержек инжекции-обнаружения для QED-тестов больше 1 000, поскольку мы выполняли QED-преобразование только для исходного кода тестов на языке C. Мы не выполняли QED-преобразование для функций системной библиотеки (например, для функций выделения памяти, печати, чтения из файлов и записи в файлы). В результате ошибки, возникающие при выполнении системой библиотечных функций операционной системы, не обнаруживались QED до тех пор, пока система не заканчивала выполнение библиотечных функций операционной системы и не возвращалась к выполнению самого теста (который преобразуется QED).
Для оригинального теста 72 % из тех же 75 точек данных не привели к ошибке в итоговом выводе программы (при сравнении с предварительно сгенерированными золотыми результатами), что свидетельствует о маскировке ошибок. Обратите внимание, что мы не наблюдали ни одного случая, когда проверка конечного результата обнаружила бы ошибку, а проверка QED - нет. В оставшихся 28 % случаев, несмотря на то, что неправильные результаты программы были обнаружены проверкой конечных результатов, задержки от инъекции до обнаружения составляли порядка миллиардов тактов (даже после того, как мы вычли накладные расходы на задержку, вносимые инструментарием QED, включая дублирование и проверку операторов).
Преобразование EDDI-V QED на уровне исходного кода C, использованное в экспериментах на рис. 17 и 18, действительно приводит к увеличению времени выполнения тестов (примерно в два раза). Однако общее время отладки, а значит, и производительность, может значительно увеличиться благодаря значительно меньшим задержкам обнаружения ошибок. 
Из этих результатов можно сделать следующие выводы.
Наблюдение 4: QED значительно сокращает время обнаружения ошибок на шесть порядков по сравнению с оригинальным тестом с проверкой конечного результата. С помощью QED задержки обнаружения ошибок сокращаются с миллиардов тактов до нескольких тысяч тактов или меньше. В 86 % случаев задержки обнаружения ошибок в тестах QED составляют менее 1 000 тактов. Оставшиеся задержки обнаружения ошибок превышают 1 000 тактов, поскольку мы выполняли QED-преобразование только на уровне исходного кода C, а не внутри библиотечных функций. Ошибки, возникающие во время выполнения библиотечной функции, не обнаруживаются QED-инструментарием на уровне исходного кода C до тех пор, пока эта библиотечная функция не будет завершена.
Наблюдение 5: QED обнаруживает ошибки, которые в противном случае остались бы необнаруженными оригинальным тестом. QED приводит к значительному (четырехкратному) улучшению покрытия.
Наблюдение 6: QED обнаруживает все ошибки, обнаруженные оригинальным тестом; включение преобразования QED не оказывает негативного влияния на способность теста обнаруживать ошибки.
B. Результаты покрытия электрических ошибок
Графики Шму для оригинального Linpack (с проверкой конечных результатов) и теста QED Linpack на основе EDDI-V представлены на рис. 18. Каждая рабочая точка частоты и напряжения классифицируется следующим образом.
1) Не загрузилась - система не смогла загрузиться.
2) Тест пройден - и оригинальный тест, и тест QED
не обнаружили ошибки.
3) Ошибка обнаружена как тестом QED, так и оригинальным
ошибка была обнаружена проверкой (проверкой QED
или проверка конечного результата), или произошел сбой системы.
4) Ошибка, обнаруженная только тестом QED - тест QED
обнаружил ошибку. В то время как оригинальный тест не обнаружил
ошибку.
На основании полученных результатов мы сделали следующие выводы.
Наблюдение 7: QED улучшает покрытие при значительном увеличении времени задержки обнаружения ошибок. Это демонстрирует рабочая точка напряжения и частоты на рис. 18 (отмечена звездочкой), где оригинальный тест прошел, но QED-тест очень быстро обнаружил ошибки. Тесты QED - это корректные тесты, то есть они не приводят систему в запрещенные состояния. Поэтому ошибки, обнаруженные QED-тестами, являются реальными ошибками в системе. Более того, на графике Шму на рис. 18 не существует точки, для которой QED-тест прошел, а оригинальный тест - нет. Это эмпирически подтверждает тот факт, что тест QED продолжает активироваться и обнаруживать ошибки, которые были обнаружены оригинальным тестом.
VIII. СОПУТСТВУЮЩАЯ РАБОТА
Существующие работы, связанные с данной статьей, можно разделить на генерацию стимулов для посткремниевой валидации, методы посткремниевой отладки, различные преобразования для отказоустойчивых вычислений, очистку памяти для отказоустойчивых вычислений и утверждения для посткремниевой валидации.
A. Автоматическая генерация стимулов для посткремниевой проверки
В разделе III мы показали, что самопроверяющие тесты [4], [52], [63] могут иметь очень большие задержки обнаружения ошибок, а также вносить чрезмерную интрузивность, особенно для ошибок в неосновных компонентах. В отличие от этого, QED сокращает время обнаружения ошибок как для ошибок внутри процессорных ядер, так и для ошибок в неосновных компонентах. QED также предоставляет систематические способы настройки интрузивности. Кроме того, QED можно применять к автоматически генерируемым функциональным тестам [8], [10], [31], [34], [50], [55] для улучшения задержек обнаружения ошибок и покрытия таких тестов. QED также может улучшить время обнаружения ошибок в тестах, которые полагаются на многопроходную проверку, где тесты выполняются несколько раз для определения ожидаемых результатов и обнаружения ошибок.
B. Методы посткремниевой отладки
Многие существующие методы посткремниевой отладки могут выиграть от сокращения времени обнаружения ошибок и улучшения покрытия с помощью QED. К ним относятся методы посткремниевой отладки, основанные на воспроизведении сбоев [65], моделировании [13], [35], буферах трассировки [2], [49] формальных методах [16], [27], [66] или отладке на базе эмулятора/ускорителя [32], [51]. QED также совместим с методами повышения наблюдаемости сигналов на кристалле при посткремниевой валидации [2], [6], [18], [43], [58]. Значительно сокращая время задержки обнаружения ошибок и улучшая покрытие, QED уменьшает количество тактов, в течение которых сигналы должны быть захвачены и проанализированы для отладки.


C. Преобразования для отказоустойчивых вычислений
Как обсуждалось в разделе IV, существуют важные различия между преобразованиями для посткремниевой проверки и преобразованиями для отказоустойчивых вычислений.
1) Преобразования для посткремниевой валидации не должны вносить излишнюю интрузивность, которая может ухудшить покрытие тестов посткремниевой валидации.
2) Во время посткремниевой валидации входные данные тестовой программы могут быть известны заранее, что открывает особые возможности для QED-преобразований по улучшению задержек обнаружения ошибок и покрытия (например, раздел IV-D) при одновременном снижении накладных расходов на выполнение тестов (например, раздел IV-B3).
3) При посткремниевой валидации уменьшение времени задержки обнаружения ошибок очень важно, поскольку время отладки, а не время выполнения теста, доминирует в общих затратах на посткремниевую валидацию [30]. С некоторыми накладными расходами на время выполнения теста можно смириться, если значительно улучшить задержки обнаружения ошибок.

D. Очистка памяти для отказоустойчивых вычислений
Очистка памяти [1], [56] используется в отказоустойчивых вычислениях для обнаружения и исправления ошибок в массивах памяти. PLC вдохновлен скраббингом памяти. Однако в дополнение к рассмотренным выше различиям между преобразованиями для посткремниевой проверки и преобразованиями для отказоустойчивых вычислений, PLC и очистка памяти отличаются следующим. 
1) Скраббинг использует коды коррекции ошибок для поиска ошибок внутри массивов памяти, но не может обнаружить ошибки, связанные с ошибками вне массивов памяти, например в кэше или контроллерах памяти.
2) Очистка памяти обычно происходит реже, чем операции ПЛК во время посткремниевой валидации; поэтому очистка памяти может привести к очень большим задержкам обнаружения ошибок.
E. Утверждения для посткремниевой проверки
Использование утверждений при посткремниевой проверке сопряжено с рядом проблем. Дизайн может содержать множество утверждений; эти утверждения должны быть тщательно проработаны, их трудно обновлять и проверять на корректность [9], [60]. Хотя существуют методы автоматической генерации утверждений для конкретного проекта [20], [24], [60], реализовать все эти утверждения в аппаратуре может быть сложно. Реконфигурируемая логика может облегчить реализацию утверждений в аппаратуре [2], [11], [21], но необходимо тщательно выбирать соответствующий набор утверждений для реализации в аппаратуре для эффективной посткремниевой отладки [42]. Кроме того, утверждения могут зависеть от сигналов, расположенных в разных областях ИС, и такие утверждения должны быть декомпозированы на компоненты, использующие только близлежащие сигналы. В отличие от этого, QED обеспечивает систематический способ выполнения обширных проверок. Проверки, вводимые QED, могут быть автоматически сгенерированы и проверены.
IX. ЗАКЛЮЧЕНИЕ
QED - это структурированный подход к посткремниевой валидации. Он позволяет решить основные проблемы посткремниевой проверки путем систематического создания тестов, которые обнаруживают ошибки очень быстро, т. е. с очень коротким временем обнаружения ошибок, а также с улучшенным покрытием. Результаты, полученные на современной коммерческой многоядерной аппаратной платформе SoC, демонстрируют улучшение задержки обнаружения ошибок на девять порядков. На той же аппаратной платформе мы также продемонстрировали способность тестов семейства QED систематически регулировать компромисс между задержкой обнаружения ошибок и интрузивностью. Результаты, полученные на аппаратной платформе Intel CoreTM i7, демонстрируют улучшение на шесть порядков латентности обнаружения ошибок и одновременно четырехкратное улучшение покрытия для электрических ошибок. Результаты моделирования с использованием списка сложных сценариев на OpenSPARC T2-подобной SoC также демонстрируют улучшение на несколько порядков в задержках обнаружения ошибок и до двух раз в покрытии. Такие короткие задержки обнаружения ошибок могут значительно повысить производительность посткремниевой валидации. QED не требует никаких аппаратных изменений и легко применим к существующим конструкциям.
Существует несколько возможностей для дальнейшего совершенствования существующих методик валидации с помощью QED. В качестве примеров можно привести следующие. 
1) Автоматизированная локализация/выявление корней ошибок путем анализа того, какие проверки QED прошли, а какие нет.
2) Систематические методы синтеза аппаратной поддержки QED для дальнейшего снижения навязчивости и улучшения задержки обнаружения ошибок. 
3) Эффективные методы отладки с использованием QED в средах эмуляции. 
4) Использование QED для идентификации сбойных ИС на системном уровне и для выявления корневых причин неисправности (NTF) ИС [14]. 
5) Методы QED для аналоговых и смешанных сигнальных блоков.