Control-Flow Checking by Software Signatures

Abstract
This paper presents a new signature monitoring technique, CFCSS (Control Flow Checking by Software Signatures); CFCSS is a pure software method that checks the control flow of a program using assigned signatures. An algorithm assigns a unique signature to each node in the program graph and adds instructions for error detection. Signatures are embedded in the program during compilation time using the constant field of the instructions and compared with run-time signatures when the program is executed. Another algorithm reduces the code size and execution time overhead caused by checking instructions in CFCSS.
A “branching fault injection experiment” was performed with benchmark programs. Without CFCSS, an average of 33.7 % of the injected branching faults produced undetected incorrect outputs; however, with CFCSS, only 3.1% of branching faults produced un- detected incorrect outputs. Thus it is possible to increase error detection coverage for control flow errors by an order of magnitude using CECSS.
The distinctive advantage of CFCSS over previous signature monitoring techniques is that CFCSS is a pure software method, i.e., it needs no dedicated hardware such as a watchdog processor for control flow checking. A watchdog task in multitasking environment also needs no extra hardware, but the advantage of CFCSS over a watchdog task is that CFCSS can be used even when the operating system does not support multitasking.

Index Terms— Assigned signatures, control flow checking, fault injection experiments, signature monitoring, software error detection.

TERMINOLOGY

Basic Block: A maximal set of ordered instructions in which its execution begins from the first instruction and terminates at the last instruction. There is no branching instruction in a basic block except possibly for the last one. A basic block terminates at either an instruction branching to another basic block or an instruction receiving transfer of CF from two or more places in the program [3].
Program Graph: From the definitions of V and E, a program can be represented by a program-graph, P. The br;, ; are not necessarily explicit branch instructions; they also represent fall-through execution paths, jumps, subroutine calls, and returns. Fig. 1 is an example.
Illegal: v; is in the suc(v;) if and only if br;, ; is included in £. Similarly, «; is in pred(v,) if and only if br,,; is included in &. If a program is represented by its P = {V, £}, then br, ; (during the execution of P) is illegal if br;, ; is not included in E [3]. This illegal branch indicates a CF error, which can be caused by transient or permanent faults in hardware such as the program counter, address circuits, or memory system [1].
Branch-Fan-in Node, Branch Insertion, Branch Deletion: If a node receives more than 2 transfers of CF it is a branch-fan-in node, i.e., the number of nodes in pred(v) > 1. A branch-insertion occurs when one of the instructions in the node is changed to a branch-instruction as the result of an error. A branch-deletion occurs when an error causes the branch-instruction of a node to change to a non branch instruction. As a result, the node without the branch-instruction merges with the node that is adjacent to it in the memory address space.
Xor-Difference of a and b: the result of performing the bitwise XOR operation of a and 8, i.e., xor-difference = a & b, where a and b are binary numbers.

I. INTRODUCTION
TRANSIENT or permanent faults introduced in a computer system during runtime can cause an incorrect sequence of instruction—execution in the program, and can cause CF errors. If the system does not perform some run-time checking, the erroneous output might not be detected and serious damage could result. Therefore, it is important to monitor the program to detect any abnormality in the CF or other error, and to take appropriate actions to avoid any incorrect output.
This paper presents CFCSS, a new assigned signature monitoring technique which checks the inter-block CF of a program using instructions, but without using any special hard- ware. The program is divided into basic blocks. A program graph is constructed based on the CF of the program. A node in the program graph represents a basic block. All nodes in the program graph are assigned different arbitrary numbers (sig- natures), which are embedded into the program during preprocessing or compile time. During program execution, a run-time signature, G is stored in one of the general purpose registers, GSR, and compared with the stored signature of the node when- ever control is transferred to a new node. For multiple branching, a runtime adjusting signature D is combined with G. The complete algorithm and an example program are in Section III.
CFCSS differs from other signature monitoring techniques in using no watchdog processor or extra hardware to achieve inter block CF checking. CFCSS uses an assigned signature technique similar to SIC [1], but does not need to send check-labels to a watchdog processor because it checks the signatures using instructions. Block Signature Self-Checking [2] is also an assigned signature technique that uses a subroutine to replace the watchdog processor. However, its drawback is that the code depends on the location of the code because the signature consists of an absolute address. The CF checking scheme in [3] is a pure software method but it constructs a database containing in- formation about concurrent CF checking, thus it might require appreciable memory overhead. The watchdog task in [4] also needs no extra hardware, but the operating system must support a multitasking environment. On the other hand, a watchdog processor or similar monitoring hardware is required in the derived signature techniques as in

- Path Signature Analysis [5];
- Signatured Instruction Streams (SIS) [6];
- Asynchronous SIS [7];
- Continuous Signature Monitoring (CSM) [8], [9];
- extended-precision checksum method [10];
- On-line Signature Learning and Checking (OSLC) [11];
- Implicit Signature Checking (ISC) [12].

They check the intra-block and inter-block CF by observing the signatures derived from the instruction bit patterns or addresses of a basic block while CFCSS checks the inter-block CF by monitoring assigned signatures in the GSR. Although they have similar function, the GSR differs from the reserved-register in [13]; the reserved-register stores the program or procedure name whereas the GSR stores the signature of the current node. The GSR is not a special or additional register in the CPU. It is one of the general purpose registers of the CPU picked by the compiler or assembler to serve as the GSR. In addition, CFCSS differs from VASC [14] in the way it embeds and checks for the signatures.
The motivation of CFCSS came from a real space experiment, the Stanford ARGOS (Advanced Research and Global Observation Satellite) project [15]. The USA (Unconventional Stellar Aspect) experiment [16] is one of the experiments that the ARGOS satellite carries, and includes a computing test-bed that has two processor boards. One of the two boards was built using only commercial-off-the-shelf components and has no hardware for error detection; only pure software techniques can be applied to detect errors. In this case, the software technique CFCSS can be used to increase the system reliability by enhancing CF error detection capability.

II. PREVIOUS WORK
Signature-monitoring and pure software methods have been proposed to check the CF of a computer system. Signature-monitoring is a method in which a signature associated with a block of instructions (one or more nodes in the CF graph) is calculated and saved somewhere during compile time; then, the same signature is generated during run time and compared with the saved one. Signatures are assigned arbitrarily (assigned signatures) or derived from the binary code or the address of the instructions (derived signatures). Structural Integrity Checking (SIC) [1] uses an assigned signature method while Path Signature Analysis (PSA) [5], Signatured Instruction Streams (SIS) [6], Asynchronous SIS (ASIS) [7], Continuous Signature Monitoring (CSM) [8], [9], extended-precision checksum method [10], and On-line Signature Learning and Checking (OSLC) [11] all use derived signatures.

In many signature monitoring techniques, dedicated hard- ware is used to calculate the run-time signatures and to compare them with the saved signatures. A watchdog processor is proposed for this purpose in [17], [18]. On the other hand, when the hardware is fixed and cannot be changed, a software method that does not need any extra hardware is necessary.
Examples of software methods are:

- assertions [4], [19];
- watchdog task [4];
- Block Signature Self-Checking (BSSC) [11];
- Error Capturing Instructions (ECT) [11];
- timers to check the behavior of the program [20];
- Available Resource-driven Control-flow monitoring (ARC) [21];
- temporal redundancy methods [22].

An assigned signature monitoring technique, Versatile Assign Signature Checking (VASC), has been proposed and evaluated in [14], in which the comparison of the ratio between CF errors and data errors in RISC and CISC processors are reported. 

III. DESCRIPTION OF CFCSS
A. The Run-Time Signature G

CFCSS checks the CF of the program by using GSR, a dedicated register which contains the run-time signature G' associated with the current node (the node that contains the instruction currently executed) in the program flow graph. Every basic block (represented by v; in the program flow graph) is identified and assigned a unique s; when the program is compiled. Under normal execution of the program (no errors), G; should equal s;. If G contains a number different from the signature associated with the current node, then an error has occurred in the program.

When control is transferred from one basic block to another, a new G is generated by a signature function f at the destination node of the branch. A signature function f is a function that updates G' for the current node by using two values:

- the signature of the previous node (source node of the branch); and
- the signature of the current node (destination node of the branch).

These two values are used because the source and destination nodes of the branch uniquely determine each branch in E.
Let the signature function

The dy = s, & sq is calculated in advance at compile-time and stored in vg. Before the br,g is taken, G contains G,. After the branch is taken, G is updated with a new value, Gy = f(G,, da), based on the previous G, and dq. If Gg = saofva, then there is no CF error. On the other hand, if Gy # sa, the na CF error has occurred.

The XOR operation was chosen as the signature function be- cause the XOR operation is better than other ALU operations for the purpose of checking or generating signatures. Because AND, OR, XOR operations use fewer gates in the ALU than addition and multiplication, they have less chance of having an error in the ALU than addition and multiplication. Now, check the cor- rect CF in the original program and minimize the probability of error in the signature function. The fewer gates the signature function uses, the lower the probability of an error in calculation of the signature functions. With AND and OR operations, given one input operand (d,) and the output result (s,), the other input operand (s,) cannot be uniquely determined. Hence, signature aliasing can occur, resulting in undetected errors. XOR does not have this aliasing problem. Therefore, the best candidate for the signature function is the XOR operation.

For example, in Fig. 2, f = f(G, d;) = @@d;; the nodes are assigned unique numbers as their signatures. Before a branch is taken, G = G; that is the same as 8}, the signature of the source node of the branch. After the branch is taken, G is updated with a new run-time signature G2:

e., the updated Gy is the same as the sy of the current v2; therefore, no error has occurred. On the other hand, suppose that an illegal branch from v, to v4 is taken; ie., the control should have moved from 2; to node v2, but an error causes an illegal branch from v1 to v4. Before the illegal branch is taken, G, = s,,as before. However, after the branch is taken, at 27, the new updated G, is different from the s4 of the new v4 because

G4 =f(G., d4) =G, Gds = G, @ (53 G 54)
=s, 0 (53 B31) #34

ie., the CF error can be detected by observing that the run-time signature is different from the new-node signature.
Before showing the exact algorithm, the outline of the algorithm for adding CFCSS to a program is described.
All basic blocks (nodes) in the program are identified and numbered. Each basic block is assigned a unique signature. The signature difference (XOR-difference between the source and destination nodes) of all branches is also calculated and stored in the destination nodes of all the branches. Whenever the control enters a new node, the run-time signature is updated to a Gnew by the f that uses the previous run-time Gyre, and the dnew as the arguments. If the Gyew is the same as the signature of the new node, the instructions in the node are executed; otherwise, it means a CF error has occurred and control is transferred to an error handling routine.

Algorithm Details
To check the CF, checking instructions are located at the top of each basic block, i.e., checking instructions are executed prior to the execution of the original instructions in the basic block. In Fig. 3, the basic block 4; consists of instructions [,, 2, .-., In and additional checking instructions located at its beginning. The checking instructions consist of 2 parts:

- the signature function that generates the run-time signature (G = G@ dy),
- the branch instruction, “br (G ¥ s;) error,” that compares the run-time signature with the signature of basic block By.
In this way, a vg, represents a B; with its checking instructions. 
Fig. 4 shows how the checking-instructions detect errors. The control is going to be transferred from v, tov,.G = G, = 3, = 1011, the signature of the current 2. After the br, 9 is taken, the f generates the new run-time

and G is compared with the sg by the “br (G # sg) error” instruction. The conditional branch instruction “br (G # s2) error” branches to the error handler if G and sy are different. Fig. 5, in contrast to Fig. 4, shows the case where an illegal branch is taken and how it is detected by the checking instructions. Before an illegal br;, 4 is taken, G has the value s;. How-

This mismatch causes the following instruction “br (G 4 s4) error’ to transfer the control to the error handling routine.
Fig. 6, in contrast to Fig. 5, shows the case in which an error occurring in the branch instruction, e.g., a bit flip in the destination field, causes an unpredictable jump to any place in the entire program, viz, any basic block in the program and any place in that basic block. G = s, at node v1. The illegal branch from v1 to v4 is taken, and the control is transferred to one of the instructions in the 24, not the checking instructions. Because a new run-time signature is not generated at v4, G still equals the previous value G,. G is not updated to s4 although control is transferred to v4. After the instructions in v4 are executed, the branch from v4 to vs is taken. At v5, G is updated to a new value G's, but it is not equal to the signature of v; because the previous G before the br4,5 was G,(=s1), not the correct value G'4(=84). Thus an illegal branch to any instruction in the node is also caught. The detailed calculation of G is shown in Fig. 6.
Fig. 7 shows the case where an illegal branch br,, 4 lands at instruction #2 of the node, “br (G ¥ s) error.” In a similar way, because the new run-time signature is not generated at 74, then G is still equal to the previous G that is not equal to s4. Therefore, “br (G # s) error” catches this mismatch, and thus the error is detected.

Illegal branches that violate the CF can be detected by assigning unique signatures to each of the nodes in the program graph, and adding signature checking instructions to them. However, there are cases where the same signature has to be assigned to multiple nodes, e.g., a branch-fan-in node. In Fig. 8, the two nodes, v1, v3, have branches to the same node, a branch-fan-in v;. As stated before, ds; = 1 G45, and there is no problem when the br is taken because

which is the signature of v5. If the br3, 5 is taken, however, the run-time signature G at vs is not equal to s5, because

However, if s; = s3 is used as the signatures, then an illegal branch from v1 to v4, or from vy to v2, will not be detected. To solve the problem of assigning the same signature to multiple predecessors of a branch-fan-in node, a D is introduced. After the G is generated by the signature generation function, G is XOR’ed with P to get the signature of the branch-fan-in node; thus, at the source node, D has to be set to the value which makes G equal to the signature of the destination node.
Fig. 9 illustrates an example where D is used in the branch-fan-in node. At vs, one more checking instruction G=G6$ Dis added. After the G = G @ ds, then G is XoR’ed with D that should be determined at the source v, and v3. Because ds is initially set to the xOR-difference between 5; and s53(d; = s1 ® 85), when the brz, 5 is taken, the updated G is already the same as s5; there is no need to change G, thus D is set to 0 at vy,

When the br3, 5 is taken, the updated G at the first line of v5 is

To make G equal to s3, the G should be XOR’ed with s; 6 s3 at the second line:
Therefore, at the 23, set D = 51 G s3.

For the bri,2, the J is not necessary because vz is not a branch-fan-in node; only one branch is coming into ve and dz is equal to s1 @ sy. Thus, the updated G at ve is equal to sg as in the previous case in Fig. 8.

In summary, if a source node has a branch to a branch-fan-in node, the source node has to have one extra instruction for D in the checking instructions in order to set D to the appropriate value before branching. If the branch to the branch-fan-in node is taken, then PD is XOR’ed with G at the destination node; other- wise, D is just ignored. In this way, arbitrary different numbers can be assigned to all the nodes in the program graph.

C. Algorithm A
Algorithm A assigns signatures to each node in a program flow-graph when a program is compiled.
N = total number of nodes in the program.

When a br,;,; is taken, if the destination v; is not a branch-fan-in node, then the run-time signature G’; is generated by the signature function f(G;, d;) = G; @ d,; and compared with the s,; of v;. If they match, then no CF error has occurred in taking br, ;. When a br,, ; is taken, if the destination 7; is a branch-fan-in node, then the run-time signature G; is generated by the signature function and D:

Gj =f (MG, dy), Dj) :

If they match, it means no CF error has occurred in taking br;, ;. CFCSS detects the types of CF errors, as presented in corollaries 1-5.
Corollary 1: An illegal branch taken to the signature function instruction the first line of the node—will be detected. Proof: Suppose that br,,; is an illegal branch, then v, ¢ pred(v,). At v;, G = s;. After the branch is taken, the new run-time signature is generated,

G=G;=G; Od; = 5; Bs, D853

5x is the signature of vu, = pred(v,;). Because s;, 8x, 8; are all
different numbers, then

G=s; Bs, P38; F 8;.

Mismatch occurs and the error is detected.
Corollary 2: An illegal branch taken to the instruction “br (G # s) error” —the second line of the node—will be detected.
Proof: Suppose that br;,; is an illegal branch and the branch is taken to line #2 of the node, i.e., skipped the signature function. Because the new G was not generated, G = s;, not 5;. Therefore, “br (G # s) error” instruction sees the mismatch and detects the error.
Corollary 3: An illegal branch to the body of the node where the original basic block sits will be detected. 
Proof: Suppose that br;,; is an illegal branch and the branch is taken to a place where one of the instructions in the original basic block is located, ie., skipped the checking instructions and landed at one of the instructions in the original basic block. Because the new G is not generated at v;, then G = s;, not s; although the control is transferred to the v;. After the instructions in v7; are executed, then br; ;, is taken, where v; = suc(v,;). The checking instructions in vz, generate the updated

G=Gr=G; Bdy = G; G (8; B sp) = 8; BS; BD Sp.
Because $;, 8x, $j are all different numbers, then
G= 5; Bs, 0sj #5;.

Mismatch occurs and the error is detected.
Corollary 4: A branch insertion inside a node will be detected if it is an illegal branch.

unless aliasing occurs (discussed in Section III-D). Mismatch occurs and the error is detected. By corollary 3, a branch to other instructions of the node will also be detected.

Corollary 5: The deletion of an unconditional branch instruction from the node will be detected.

Proof: Suppose that the branch instruction br,,; at v; is changed to another instruction; then, br;,; is removed from EF and an adjacent v;, is merged into v;. Then, the signature of this node is changed from s; to s;, in the middle of the node where vu; and v;, are merging; thus, the G should be updated to s,. However, because v; ¢ pred(v;,), then G will not match with sy. Therefore, the error is detected. This is similar to the case where an illegal branch br;,, ¢ E occurs.

D. Aliasing If multiple nodes share multiple branch-fan-in nodes as their destination nodes, aliasing could occur between legal and illegal branches, and cause an undetectable CF error.

In Fig. 10, vs is a branch-fan-in node with 3 source-nodes ul, vo, us(pred(v;) = {u. v2, v3}). Node ug is also a branch-fan-in node but it has only 2 source-nodes te, v3, not v;(pred(vg) = vz, vg). According to algorithm A, step 3.4—first, the ds of vs is determined as d; = sq @ s5. The runtime signature Dz of v2 is Dz = so B sg = 0000, the Dz = 82 6 83, and D, = s2 & 81. For the branch-fan-in ve, the ds should also be calculated with v2(dg = s2 @ sg) because {v2, v3} is a subset of both pred(v;) and pred(vg). In other words, either dg = so & sg or dg = 83 G sg. However, because pred(vs) = {u1, va, vg} and pred(vg) = {v2, v3} have the same subset {v2, vg}, and ds of us is already calculated with the signature of v2, then dg of vg should also be calculated with the signature of v2: dg = s2 ® sg. As a result, both vs

Fig. 10. Aliasing that causes an undetectable flow-error.

and vg have the difference signature calculated with the same
so(ds = $2 635,dg = 52 6 56).

Suppose that an illegal branch br,,g occurs and lands at the first line of vg, where the instruction of signature function I(Gprev, dg) is located. Gorey is Gy = 51 and updated

The updated G'g = sg; therefore, this illegal branch is not detected. This aliasing error is caused by the fact that more than 2 branch-fan-in nodes have their signature differences calculated with the signature of the same node, and their predecessor sets are not equal. More specifically, the condition for aliasing error is:

Aliasing error occurs when dj = s, ® 3;, dj; = 83 @ 8j, but pred(v;) 4 pred(v;). If pred(v;) — pred(v;) 4 9, an il- legal branch from a node in pred(v;) — pred(v; )—assuming pred(v;) C pred(v;)—to vj; is undetectable when that branch is taken to the location of the instruction for the signature function.

If the illegal branch is taken to any location except “the first line of the node”’—the instruction for the signature function—the CF error is detected because the new run-time signature associated with the destination node is not generated. In other words, the illegal branch is detected unless it lands at the first line of the destination node that satisfies the condition described in the previous paragraph. With this observation, one can avoid the undetectable illegal branch if signatures are assigned to the nodes in the following way.

If 1 bit-error is assumed, and the Hamming distance between the “addresses of the first instructions in vs and vg” is greater than 1, then this undetectable illegal branch is avoided; 1 bit-error in the destination field of the branch instruction at v; cannot cause an illegal branch to the location of the first line of vg. Similarly, if m-bit-error is assumed, and the addresses of the first instructions of all successor nodes are different by Hamming distance greater than m, then undetectable illegal branches caused by aliasing are avoided.

IV. SIMULATION RESULTS

Seven benchmark programs are chosen for the experiment:

- LZW (compression);
- FFT (Fast Fourier Transform);
- Matrix multiplication;
- Quick sort;
- Insert sort:
- Hanoi;
- Shuffle.

First, the source files were compiled, and assembly codes were generated for MIPS architecture. One of the following faults was randomly applied to the assembly code:
- a branch deletion in which the branch instruction is replaced by a nop instruction,
- a branch creation in which an unconditional branch is randomly inserted into the program,
- a branch operand change where the immediate field of the instruction is corrupted.

Then, a machine code was generated by compiling the faulty assembly program and executed on an SGI Indigo that uses the R4400 MIPS processor. Table I shows the results of 500 iterations.

- Row #2: The numbers (incorrect result) indicate the fraction of faults that cause the programs to produce incorrect results that go undetected.
- Row #3: Erroneous result is “infinitely produced” because the fault creates an infinite loop in the program.
- Row #4: The processor does not respond to inputs, so the processor must be manually stopped.

- Row #5: The fraction of faults that are detected by the operating system of the machine. A segmentation fault and failed assertion are examples of faults detected by the operating system. Some branch faults might not affect the outputs of the program. For example, suppose the constant field of a conditional branch instruction is corrupted. If the condition is not satisfied, the branch instruction is never taken, and the fault in the constant field has no effect on the outputs.

- Row #6: These are faults that have no effect on the outputs.

LZW (comp.) FFT Matrix mult. Quick sort Insert sort Hanoi Shuffle
Incorrect result 21.0% 11.8% 26.6% 15.8% 26.2% 12.0% 22.8%
Infinite erroneous result 3.6% 16.8% 1.0% 0% 1.2% 2.0% 0%
Processor hung 16% 16.8% 6.2% 17.8% 12.2% 7.8% 12.6%
Detected by OS 57.4% 36.0% 55.0% 50.0% 50.4% 54.6% 50.4%
Correct result 16.4% 18.6% 11.2% 16.4% 10.0% 23.6% 14.2%
Total 100% 100% 100% 100% 100% 100% 100%
Incorrect output undetected 26.2% 45.4% 33.8% 33.6% 39.6% 18% 35.4%

TABLE IL
RESULTS OF BRANCH-FAULT INJECTION INTO THE PROGRAMS WITH CFCSS

LZW (comp.) FFT Matrix mult. Quick sort Insert sort Hanoi Shuffle
Detected by CFCSS 30.8% 34.4% 41.0% 38,8% 37.2% 34.6% 40.0%
Incorrect result. 0.8% 0% 2.4% 0.6% 0.6% 0.0% 1.6%
Infinite erroneous result 0.2% 2.8% 0% 0% 0% 0.2% 0%
Processor hung 1.0% 1.4% 0.6% 2.8% 34% 16% 1.6%
Detected by OS 12.0% 13.6% 9.4% 17.4% 11.0% 8.0% 7.2%
Correct result 55.2% 47.8% 46.6% 50.4% 47.8% 55.6% 49.6%
Total 100% 100% 100% 100% 100% 100% 100%
Incorrect output undetected 2.0% 4.2% 3.0% 3.4% 4.0% 1.8% 3.2%


- Row #7 (Last row): The fraction of faults that produced incorrect outputs without being detected: the sum of rows #2, #3, #4. On average, 33.7% of the injected faults are not fault-secure.

For part #2 of the experiment, CFCSS is included in the assembly source code, and the branch fault (branch deletion, branch creation, and operand change) is inserted into the code. The resulting assembly code is compiled and executed. Table IT shows the result of 500 iterations; the last row is the fraction of faults that result in error and are not detected by either CFCSS or the operating system.

The graph in Fig. 11 illustrates the fraction of faults that are not detected for both the original program and the program with CFCSS. CFCSS shows high error detection capability: In the programs without CFCSS, an average of 33.7% of the injected branching faults produced undetected incorrect outputs; however, in the programs with CFCSS, only 3.1% of branching faults produced undetected incorrect outputs. The simulation results show that CFCSS increased the error detection capability by a factor of 10.

Table III shows the code-size overhead introduced by CFCSS in the benchmark programs that were used in the fault-injection simulations. Table II includes execution-time overhead for the benchmark programs. Column #2 gives the number of instructions before adding checking instructions to the original program. Column #3 gives the number of checking instructions added. Column #4 is the average size of basic blocks in the program. Columns #5 and #6 show the overhead of adding the checking instructions to the original program: the ratio of checking instructions to original instructions and execution time overhead. These numbers are based on the MIPS architecture where the “br (G ¥ s) error” is translated into two instructions: a compare-instruction followed by a branch-instruction. This might not be the case in other architectures; therefore, the numbers could be different—depending on processor architecture.

Calculation-intensive programs, such as FFT, have larger basic blocks than data-analysis programs. Thus the overhead is smaller for calculation-intensive programs. On the other hand, programs such as sorting and searching have small basic blocks because they have frequent branch instructions; therefore, the overhead of checking instructions in these programs is higher compared to calculation-intensive programs.
V. OVERHEAD REDUCTION AND EXAMPLES
For the overhead of algorithm A, each node has between two to four additional instructions. If the average size of one basic block is seven to eight instructions [23], then the code size over- head is about 25% to 43%. Every node has one instruction that compares the run-time signature with the signature of that node. If it is not critical to detect an error immediately (if a longer latency for detecting an error is allowed) then comparing the signatures can be delayed. Once an illegal branch is taken, and the run-time signature becomes unequal to the signature of the node, then the run-time signature does not match the signatures of the following nodes in the CF because all signatures are different in the program graph. Therefore, the comparison instruction can be put only in some of the nodes and a mismatch of the signatures in those nodes can be detected only after an illegal branch. Algorithm B reduces overhead in algorithm A by postponing the comparisons. The difference between algorithms A and B is in step 3.5. Instead of comparing signatures at every node, algorithm B compares the signatures at the nodes where it is important to detect the CF errors.
Fig. 12 has two examples of algorithm B. In Fig. 12(a), the run-time signature and the node signature are compared only at ug. The overhead for v;, v2, vz, v7 is only the f(G, d). The branch-fan-in v; has two instructions for {({(G, d), D). Nodes va and vg that are branching to the branch-fan-in v; have two instructions: one for signature function and the other for loading D. Algorithm A has an overhead of 30% in Fig. 12(a), assuming that all basic blocks have eight instructions. Using algorithm B for the same example, the overhead is reduced to 19%. However, the average detection latency in algorithm B is 22.8 instructions while that in algorithm A is 4.5 instructions.
Fig. 12(b) is an example of a loop in which the signature is checked only at the end of the loop instead of checking it at every node in the loop. Similar to the example in Fig. 12(a), only ve has “br (G # s) error” instruction. The overhead of applying algorithm A to this loop example is 37.5% with the latency of 4.5 instructions. When algorithm B is applied, the overhead is reduced to 27%, but the average detection latency increases to 21.8 instructions.
Fig. 13 shows four different nodes with associated checking instructions. A check node is a node that has the comparison instruction “br (G # s) error.” The comparison instruction is excluded from the node that is not a check node. A node can be a combination of two types: a branch-fan-in and a check node.

