The Control Flow Checking by Software Signature (CFCSS) technique, proposed by Oh et al., is an inter-block CFE detection technique [27]. To implement CFCSS, two compile-time variables are assigned to each basic block. The first variable is the compile-time signature si which is a unique randomized bit sequence. The second variable di represents the valid branch of the first predecessor to the current basic block. It is calculated as follows di = si ⊕ spred1 where spred1 is the compile-time signature of the first predecessor basic block. The ⊕ symbol refers to the exclusive or operation.
The run-time signature G is updated at the beginning of each basic block as follows G = G ⊕ di. Next, the result of the update is verified. In an error-free run, the run-time signature should now hold the same value as the compile-time signature of the current basic block. When a basic block has multiple incoming edges, the signature update uses an extra variable D. This variable is updated by the predecessor basic blocks and assures that the run-time signature can be updated to the correct value, regardless of which predecessor has executed. For the first predecessor D is updated to the value zero, for all other predecessors D is updated with the result of the exclusive or operation of the signature of the current predecessor and the first predecessor. Then, the run-time signature update is given as G = G ⊕ di ⊕ D. Using the CFG of Fig. 2.4, our implementation of CFCSS is shown in Fig. 2.6. To store and use the needed run-time variables, registers are used. In order for these registers to be available, they must be reserved at the start of the compilation process. Regarding Fig. 2.6, the run-time signature G is held in register r11 and the run-time value for D is held in register r10. The first instruction each basic block executes is the update of the run-time signature, implemented by the exclusive or instruction (EOR). The upper-right basic block shows how the update using D is implemented. Here, the run-time update is split into two instructions: 1) the regular signature update using di, instruction 0x1f4, and 2) the extra update with D, instruction 0x1f8. Next, each basic block executes the verification of the run-time signature, by comparing its value with the compile-time signature. This verification is implemented as the comparison instruction (CMP). When there is a mismatch between both values, control is transferred to the error handler located at address 0x250. This transfer is implemented by the branch-not-equal instruction (BNE). The last CFCSS-related instruction each basic block executes, is the update for the variable D implemented as the move instruction (MOV). We make an exception here for basic blocks that exit from the current function or program. The two lower basic blocks are exit blocks and therefore do not update register r10. We do not update the run-time variables in exit blocks because they have no successor that can verify that update.