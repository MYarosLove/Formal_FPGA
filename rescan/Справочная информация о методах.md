B. Справочная информация
B.1. QED и преобразование EDDI-V QED - это метод тестирования, который использует существующие тесты проверки системы и автоматически преобразует их в набор новых тестов с помощью различных преобразований QED [Lin 12, Lin 14]. Тесты QED продемонстрировали высокую эффективность для быстрого обнаружения логических и электрических ошибок в процессорных ядрах, неосновных компонентах, ускорителях и компонентах, связанных с функциями управления питанием [Campbell 15, Hong 10, Lin 12, 14, 15a]. Здесь мы рассмотрим преобразование EDDI-V, которое является основной темой данной работы. EDDI-V [Hong 10, Lin 14] направлена на борьбу с ошибками внутри процессорных ядер путем частой проверки результатов оригинальных инструкций на результаты дублирующих инструкций. Сначала регистры и пространство памяти делятся на две половины, одна из которых предназначена для оригинальных инструкций, а другая - для дублированных. Затем соответствующие регистры и ячейки памяти для оригинальных и дублированных инструкций инициализируются одинаковыми значениями. Затем для каждой инструкции load, store, arithmetic, logical, shift или move в оригинальном тесте EDDI-V создает соответствующую дублирующую инструкцию, которая выполняет ту же операцию, но использует регистры и память, зарезервированные для дублирующих инструкций. Дублированные инструкции выполняются в том же порядке, что и оригинальные. Преобразование EDDI-V также вставляет периодические проверочные инструкции, которые сравнивают результаты выполнения оригинальных инструкций с результатами дублированных инструкций. Каждая проверочная инструкция имеет вид: CMP Ra, Ra′, где Ra и Ra′ - оригинальный и (соответствующий) дублированный регистры, соответственно. Несоответствие в любой проверочной инструкции означает ошибку.

B.2. Символический QED
Символический QED [Lin 15a, Singh 18] объединяет QED-преобразования с Bounded Model Checking (BMC). Bounded Model Checking использует решатель булевой удовлетворимости (SAT) для проверки возможности нарушения заданного свойства за ограниченное число циклов для данного RTL-проекта, начиная с конкретного состояния. Если решение найдено, создается контрпример (конкретная трасса, нарушающая свойство, т. е. трасса ошибки). BMC гарантирует, что если контрпример найден, то он является контрпримером минимальной длины [Clarke 01]. Символический QED создает задачу BMC, которая перебирает все возможные тесты EDDI-V. Инструмент BMC ищет контрпримеры к свойствам вида:
Ra == Ra′,
где Ra - оригинальный регистр, а Ra′ - соответствующий дублирующий регистр, записанный во время теста EDDI-V. Без дополнительных ограничений механизм BMC будет находить ложные контрпримеры. Например, последовательность команд MOV R1, 1; MOV R17, 2; CMP R1, R17 приводит к тому, что R1 ≠ R17. Это неравенство не вызвано реальной ошибкой. Чтобы избежать подобных ситуаций, мы требуем, чтобы все контрпримеры были QED-совместимыми. Мы определяем QED-совместимый след ошибки как последовательность входов со следующими свойствами: 
1. Входы должны быть корректными инструкциями. Спецификации допустимых инструкций можно получить из архитектуры набора инструкций (ISA) процессорного ядра; 
2. Последовательность инструкций является тестом EDDI-V; 
3. Оригинальные и дублирующие подпоследовательности инструкций должны выполняться в одном и том же порядке. 
4. Сравнение между оригинальным регистром R и соответствующим ему дублирующим регистром R′ происходит только в том случае, если оригинальная и соответствующая дублирующая инструкции были зафиксированы.

Для обеспечения того, чтобы BMC рассматривал только QED-совместимые трассировки ошибок, необходимо ограничить входные данные для проектирования. Это делается путем добавления модуля QED на этап выборки процессорного ядра во время BMC. Модуль QED автоматически преобразует последовательность исходных инструкций в QED-совместимую последовательность, например, как на рис. 5. Модуль QED требует, чтобы входная последовательность состояла только из корректных инструкций, которые читают из или записывают только в регистры и память, выделенные для исходных инструкций (условия могут быть заданы непосредственно в инструменте BMC). После выполнения подается сигнал (qed_ready), когда оригинальный и соответствующий дублированный регистры должны содержать одинаковые значения в ситуациях, свободных от ошибок, т. е. инструмент BMC должен проверить это свойство:
qed_ready ® ⋀=∈{?..AC1} Ra == Ra′,B

где N - количество регистров, определяемое ISA. Здесь (для a ∈ {0. . N/2 - 1}) Ra и Ra′ соответствуют регистрам, выделенным для оригинальных и дублированных инструкций, соответственно.

Начальное состояние для выполнения BMC также должно быть QED-согласованным состоянием, в котором значение каждого оригинального регистра или ячейки памяти совпадает с соответствующим дублированным регистром или ячейкой памяти. Это необходимо для предотвращения генерации ложных контрпримеров. Один из способов получить такое состояние - запустить тест EDDI-V в симуляции и остановиться сразу после того, как QED-проверка сравнит все значения регистров и памяти.

B.3. S2QED
S2QED [Fadiheh 18] - это техника, которая расширяет Symbolic QED за счет включения символической инициализации. Как и техника в этой статье, S2QED также фокусируется строго на тестах EDDI-V. S2QED инициализирует две копии центрального процессора (назовем их CPU 1 и CPU 2). Затем определяется произвольное отображение один-к-одному между регистрами двух экземпляров CPU. Новое понятие "согласованность QED" определяется, когда все значения в регистрах CPU 1 совпадают со значениями в соответствующих сопоставленных регистрах CPU 2. Затем CPU 1 ограничивается стартом из конкретного состояния "промытый трубопровод", а CPU 2 стартует из символического начального состояния, с дополнительным ограничением, что оба CPU удовлетворяют этому понятию согласованности QED при инициализации.
Затем, в начале проверки, CPU 1 считывает действительную инструкцию (называемую проверяемой инструкцией, или IUV), а CPU 2 считывает соответствующую дублирующую инструкцию QED (т. е. ту же инструкцию с заменой каждого регистра CPU 1 на соответствующий маппируемый регистр CPU 2). Затем CPU 1 ограничивается выборкой NOP до фиксации IUV, в то время как CPU 2 может получать произвольные допустимые инструкции (рассматриваемые формальным инструментом как символы). Затем S2QED пытается доказать, что в момент фиксации IUV регистры в двух CPU всегда будут оставаться QED-согласованными. 
Техника, разработанная в данной статье, отличается от S2QED несколькими ключевыми аспектами: 
1) S2QED не требует модуля QED или регистраторов QED во время предварительной верификации, тогда как методика, разработанная в данной работе, требует; 
2) S2QED требует дублирования CPU (только во время предварительной верификации), тогда как методика, разработанная в данной работе, требует только одного CPU; Однако для мотивации методики, представленной в данной работе, ниже приведен пример ошибки, которую можно поймать только с помощью методики, разработанной в данной работе, а не S2QED.
Пример. Когда все регистры в регистровом файле содержат значение 1, следующая запись в регистр повреждается.
Поскольку эта ошибка требует, чтобы все регистры имели одно и то же значение, все возможные отображения регистров между CPU 1 и CPU 2 сохраняют QED-согласованность во время активации ошибки. Для любого IUV ошибка воздействует на оба процессора одинаково, и разницы между конечными значениями в соответствующих сопоставленных регистрах обнаружить невозможно. В отличие от этого, разработанная в данной статье техника заставляет оригинальную и дублирующую инструкции выполняться последовательно. Это позволяет активировать ошибку во время выполнения либо оригинальной, либо дублирующей инструкции, но не другой, поэтому ошибка может быть обнаружена.

B.4. Новый модуль QED для однопроцессорных ядер
Здесь мы опишем модуль QED, который мы использовали для запуска Symbolic QED на однопроцессорных ядрах. Этот новый QED-модуль отличается от QED-модуля, использованного в [Singh 18], и мы показали (см. раздел 3), что существуют специфические ошибки, которые можно отловить только с помощью этого нового QED-модуля, но не с помощью предыдущего. Псевдокод модуля QED приведен на рис. 6(a). Входами являются: 
1) enable, который отключает модуль QED, если он равен 0; 
2) next_instruction - следующая выбранная последовательная инструкция для выполнения; 3) fetch_next - высокий уровень, когда ядро готово к приему инструкции (т. е. этап выборки не остановлен); 
4) original, который указывает модулю на выполнение оригинальной инструкции (при высоком уровне) или дублирующей инструкции (при низком уровне). Выходами модуля QED являются: 1) instruction_valid, который указывает, является ли выходная инструкция действительной или нет; и 2) instruction_out, который указывает инструкцию, которая должна быть выполнена. 

Модуль QED имеет внутренние переменные: 1) queue - структура данных очереди, используемая для хранения ранее просмотренных оригинальных инструкций, которые еще не были выполнены в дублирующей подпоследовательности; 2) head_instruction - предыдущая глава очереди; 3) insert_valid - истина, если модуль QED может выполнить оригинальную инструкцию; 4) delete_valid - истина, если модуль QED может выполнить дублирующую инструкцию; 5) duplicate_instruction - следующая инструкция в дублирующей подпоследовательности, которая будет выполнена (используется только в том случае, если original равен 0).
Чтобы запустить Symbolic QED, нам также нужно определить, когда безопасно выдавать проверки QED, т. е. логику для сигнала qed_ready. Псевдокод для определения qed_ready для модуля QED на рис. 6(a) приведен на рис. 6(b). Чтобы избежать ложных срабатываний, мы проверяем QED только тогда, когда в регистры, сопоставленные с оригинальными инструкциями, и в регистры, сопоставленные с дублирующими инструкциями, было произведено равное количество фиксаций (записей). Этого можно добиться, отслеживая количество фиксаций оригинальных и дублирующих инструкций в регистровом наборе, как показано на рис. 6(b). Для простоты на рис. 6(b) мы предполагаем, что за цикл может быть зафиксирована не более одной инструкции. Для суперскалярных процессоров, которые могут фиксировать несколько инструкций в одном цикле, мы просто отслеживаем все соответствующие пары сигналов write_valid (который сообщает, являются ли входные данные для записи действительными) и write_address (который обозначает адрес для записи данных), имеем отдельный сигнал is_original (который определяет, соответствует ли адрес "оригинальному" или "дублирующему" расположению) для каждого адреса, и позволяем счетчикам оригиналов и дубликатов увеличиваться несколько раз на основе оценки каждого из сигналов is_original.
В отличие от этого, модуль QED из [Singh 18] требует, чтобы все оригинальные инструкции завершились, наступил период ожидания для промывки конвейера ядра и, наконец, были выполнены дублирующие инструкции, прежде чем будет подан сигнал qed_ready. Данный модуль QED вместо этого позволяет произвольно чередовать (просто передавая управление исходным входом рис. 6(a) инструменту BMC) последовательности оригинальных и дублирующих инструкций, не требуя периода ожидания перед проверкой QED.
Логика разрешения готовности QED на рис. 6(b) может быть усовершенствована: 
1. Текущая логика разрешения готовности QED применима только к однопроцессорным ядрам, поскольку для многоядерной системы потребуется модификация логики qed_ready для учета оригинальных и дублирующих фиксаций на всех ядрах. Это может быть проблематично в ситуациях, когда несколько ядер работают с общим адресным пространством, поскольку проверки QED требуют согласованности кэша, чтобы избежать ложных срабатываний. Для простоты мы не рассматриваем эту ситуацию в данной статье.
2. Для некоторых процессоров, например суперскалярных процессоров с явным переименованием регистров (MIPS 10000 [MIPS 96] и ARM's Cortex-A15 [ARM]), определение оригинальной или дублирующей инструкции не может быть сделано только по месту записи (в отличие от рис. 6(b)). Эту проблему можно легко исправить, включив текущее состояние таблицы сопоставления регистров в качестве входного параметра функции is_write_to_original_space. Кроме того, каждый раз, когда происходит проверка QED, необходимо использовать ту же таблицу отображения для сопоставления каждого логического адреса с его текущим физическим адресом, прежде чем сравнивать "оригинальные" и "дублированные" значения. Однако ядра RISC-V, используемые в данной работе, не имеют этой проблемы.