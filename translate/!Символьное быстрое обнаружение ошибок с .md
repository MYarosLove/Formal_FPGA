<font face = "Times New Roman" size = 5 color = black > 

**Символьное быстрое обнаружение ошибок с использованием символьного начального состояния для предварительной верификации**

Symbolic Quick Error Detection Using Symbolic Initial State for Pre-Silicon Verification

Мохаммад Рахмани Фадихех*, Йоаким Урдал*, Шринивас Шашанк Нутхакки',
Субхасиш Митра*, Кларк Барретт*, Доминик Штоффель*, Вольфганг Кунц*.

**Аннотация**

В связи с потребностью в высоконастраиваемых процессорных ядрах для IoT и смежных приложений возрос интерес к эффективным, но недорогим методам проверки систем-на-чипе (SoC). В данной статье мы вновь обращаемся к проблеме верификации процессоров и представляем радикально иной подход по сравнению с существующим. Предложенный подход отличается высокой степенью автоматизации и использует последние достижения в области посткремниевой валидации методом быстрого обнаружения ошибок (Quick Error Detection, QED) и символьным быстрым обнаружением ошибок (Symbolic Quick Error Detection, SQED).
В данной работе мы модифицируем SQED, включив символическое начальное состояние в его анализ на основе BMC, и обобщаем подход до метода S2QED. В качестве первого преимущества, QED может отделить логические ошибки от электрических ошибок при посткремниевой проверке на основе QED. Во-вторых, он также вносит большой вклад в предварительную верификацию, доказывая, что выполнение каждой инструкции не зависит от ее контекста в программе. Ручные усилия для предложенного подхода на порядки меньше, чем для обычной проверки свойств. Наши экспериментальные результаты демонстрируют потенциал S2QED на примере процессора Aquarius с открытым исходным кодом.
Индексные термины - формальная верификация, посткремниевая валидация, быстрое обнаружение ошибок, S2QED.

**I. ВВЕДЕНИЕ**
Несмотря на то, что сегодня на методы предварительной верификации приходится более 50 % всех усилий в цикле проектирования системы-на-кристалле (SoC) [1], они часто оказываются недостаточными для обнаружения сложных ошибок в конструкции до вывода на печать [1], [2], [3]. Эти ошибки приходится находить при посткремниевой проверке и исправлять или обходить путем исправления или перепрошивки, что резко увеличивает время и стоимость проектирования [3].
С увеличением сложности микроархитектур и растущим спросом на высоко оптимизированные и индивидуально настраиваемые процессоры, например, для приложений Интернета вещей (oT), верификация процессоров становится все более сложной задачей при проектировании SoC. В этой статье мы рассматриваем возросшую потребность в недорогих, но высокоэффективных методах верификации процессоров и предлагаем принципиально новый подход для этой цели.
Процессоры задаются в моделях на уровне программиста, называемых архитектурой набора инструкций (ISA). ISA описывает инструкции как независимые операции системы, которые выполняются отдельно друг от друга; однако реализованная микроархитектура обычно выполняет несколько инструкций параллельно с помощью статического и динамического конвейеризации и смежных концепций. В результате сложных взаимосвязей между различными инструкциями, выполняемыми в последовательности, в современных микроархитектурах серьезной проблемой является доказательство того, что правильное выполнение каждой инструкции не зависит от других инструкций в конвейере и от предыдущей истории программы. Другими словами, необходимо показать, что семантика инструкции не зависит от ее контекста в программе, а однозначно определена в данной реализации. Это доказательство, однако, вовсе не является тривиальной задачей. Об этом свидетельствуют публикуемые для современных процессоров листы с ошибками, в которых часто описываются десятки функциональных ошибок, связанных с этой проблемой. Предлагаются "обходные пути", которые должны быть учтены программистом или реализованы в компиляторе. В таких случаях "обходной путь" обычно заключается в ограничении использования инструкции определенным контекстом, в котором ее поведение корректно. Один из основных вкладов данной работы заключается в том, что функциональные ошибки этой категории будут предотвращены с помощью предлагаемого подхода.
На сегодняшний день промышленная практика верификации процессоров в значительной степени опирается на моделирование. Большинство методик основаны на покрытии кода, покрытии переключения сигналов или аналогичных понятиях и не позволяют полностью исследовать пространство состояний. Поскольку многие сложные ошибки в микропроцессорах, как было описано выше, связаны с логикой управления и зависят от состояния системы [4], они могут не поддаваться моделированию и оставаться необнаруженными до посткремниевой проверки.
За прошедшие годы в области формальной верификации процессоров было проведено огромное количество исследований. Мы лишь вкратце опишем некоторые краеугольные камни, многие из которых датируются не менее чем десятилетием. Дилл и Берч использовали логику без кванторов, содержащую неинтерпретируемые функции, для верификации конвейерного процессора [4], [5]. Их работа вдохновила множество других исследований, в которых абстрагировались от сложности тракта обработки данных в сочетании с различными булевыми методами, такими как символьные средства проверки моделей [6], [7] и процедуры принятия решений на основе BDD [8]. Эти методы обычно работают на абстрактных моделях процессора. Однако большинство сложных ошибок появляется в RTL-описании конструкции [9] и может быть легко пропущено в абстрактной модели.

В прошлом было предложено множество подходов к применению формальной верификации на основе SAT [10] для SoC и процессоров. В практическом исследовании [11] было показано, что методы проверки свойств на основе SAT могут "полностью" [12], [13] проверить RTL-описание на соответствие его формализованной спецификации ISA. Хотя это может устранить все ошибки функционального дизайна из таблиц ошибок процессора, ручная работа при таком подходе значительна и, как сообщается, составляет около 2 000 строк кода (LoC) в месяц на человека [11]. Более автоматический подход к проверке RTL-описаний микропроцессоров на основе SAT предложен в [9]. Хотя он может быть выполнен с меньшими затратами ручного труда по сравнению со стандартной проверкой свойств, ему не хватает покрытия, достигаемого проверкой свойств. Использование метода доказательства Bounded Model Checking (BMC) [14] эффективно для поиска контрпримеров, однако не позволяет сделать достоверный вывод об отсутствии ошибок.
В связи с возросшим интересом к недорогим решениям для высокоэффективной верификации процессоров, о чем говорилось выше, в данной статье мы по-новому взглянем на проблему, используя современные тенденции и разработки в области посткремниевой валидации. Символическое быстрое обнаружение ошибок (SQED) [15], [16] - это новый и совершенно иной подход к решению проблемы верификации SoC. Этот метод, предназначенный в первую очередь для локализации ошибок при посткремниевой валидации, также полезен для предварительной верификации. Он основан на программных тестах Quick Error Detection (QED) [17] и использует BMC в качестве метода доказательства. SQED пытается найти кратчайшие возможные QED-тесты, которые выявляют функциональные ошибки в конструкции.
Несмотря на свою эффективность для посткремниевой локализации ошибок и поиска ошибок в предварительной верификации, SQED не дает четко определенного заключения о функциональной корректности дизайна или отсутствии определенных классов ошибок. Это не только проблема предварительной верификации, но и проблемы посткремниевой валидации. Если функциональная ошибка в конструкции, называемая также "логической ошибкой", ускользает от предварительной верификации, это значительно усложняет локализацию ошибки в неудачном QED-тесте, поскольку посткремниевая валидация должна четко различать электрические и логические ошибки, чтобы найти основную причину сбоя.
В этой статье мы предлагаем S2QED (Symbolic initial state Symbolic Quick Error Detection) для обнаружения логических ошибок в процессорах. Он основан на расширениях и модификациях SQED и использует символическое начальное состояние в своем анализе для повышения общности результатов.
Вот основные характеристики SQED:
1) Как показано в данной работе для статических процессоров, S2QED формально доказывает отсутствие всех логических ошибок, обнаруживаемых определенным классом QED-тестов [17]. Следовательно, при посткремниевой валидации любой неудачный QED-тест (из этого класса) гарантированно не будет вызван электрической ошибкой, если дизайн прошел S'QED при предварительной верификации.
2) S2QED вносит вполне определенный вклад в предварительную верификацию кремниевых процессоров. Она доказывает, что каждая инструкция выполняется одинаково, независимо от ее контекста в программе, гарантируя тем самым уникально определенную семантику инструкции.
3) S2QED в значительной степени автоматизирован и требует лишь небольшой информации "белого ящика" о конструкции. 
4) S2QED, в отличие от других методов верификации процессоров, не опирается на исполняемые модели спецификаций и не требует формальной спецификации модели ISA. 
Полезность этого метода демонстрируется в данной статье на примере верификации процессора Aquarius с открытым исходным кодом, 5-ти ступенчатого конвейерного процессора с последовательной передачей данных, основанного на ISA SH2. Как будет показано, S2QED способен доказать корректность процессора в отношении QED-обнаруживаемых ошибок за разумное время. Он также обнаруживает ошибки, которые не могут быть обнаружены SQED. Объем ручной работы для этого метода оказался значительно меньше, чем для современных методов проверки свойств.
Остальная часть статьи организована следующим образом. В разделе II дается краткий обзор QED и SQED. В разделе II обсуждается первый подход к обобщению SQED с помощью доказательств любого состояния. В разделе IV дается подробное объяснение метода S2QED. В разделе V приводятся экспериментальные результаты, а в разделе VI - заключительные замечания.


**II. ИСТОРИЯ**
A. Быстрое обнаружение ошибок
Быстрое обнаружение ошибок (QED) опирается на набор программных преобразований, которые превращают существующую программу в тесты QED путем вставки различных проверочных инструкций для уменьшения времени задержки обнаружения ошибок. Обнаружение ошибок с использованием дублированных инструкций для проверки (EDDI-V) является одним из таких программных преобразований, которое направлено на поиск ошибок внутри процессора. В этой статье мы сосредоточимся на тестах EDDI-V.
EDDI-V разделяет регистровый файл на два набора, называемых оригинальными и дублированными регистрами, с уникальным отображением соответствия между этими двумя наборами. Таким же образом дублируется пространство памяти программы и устанавливается соответствие между соответствующими программными переменными. В начале программы каждая пара соответствующих регистров (ячеек памяти) должна быть инициализирована одними и теми же данными. EDDI-V преобразует существующую программу в QED-тест, дублируя последовательности инструкций таким образом, что оригинальная последовательность работает только с одной половиной регистрового файла (пространства памяти), а дублирующая - с другой. В конце каждой последовательности любое несоответствие между результатами вычислений оригинальной и дублированной последовательности указывает на ошибку и баг в конструкции. Это проверяется короткой последовательностью проверочных инструкций, которые сравнивают значения и при несовпадении переходят к обработчику ошибок.
На рис. 1 показан пример такой тестовой последовательности QED. Регистры Rig...R3 являются дублирующими версиями регистров Ro...Ry5. Предположим, что в конвейере имеется ошибка, которая активизируется при наличии двух инструкций на этапах IF и ID, соответственно, которые записывают в регистр RO два разных значения. Предположим, что в результате ошибки следующая инструкция ошибочно декодируется как NOP. Показанная последовательность инструкций способна обнаружить ошибку, как описано в комментариях к отдельным инструкциям. В процессоре, не содержащем ошибок, после дублирования последовательности все соответствующие пары регистров (и ячейки памяти) должны иметь одинаковое содержимое. Мы говорим о QED-согласованном состоянии регистров.


В дальнейшем мы ограничиваем наше описание регистровым файлом. (Аналогично моделируется пространство памяти в тестах EDDI-V.) В качестве подготовки к последующему обсуждению определим регистровое соответствие между набором оригинальных регистров, O, и набором дублированных регистров, D. Регистровое соответствие - это биективная функция m : O > D. Например, для процессора с N регистрами мы можем определить O = {Ro,fRi,...,Rnjea}, D = {Ryo Rnjoy,.-.,Rn-1} и m(R;) = Rizn/2- QED-согласованное состояние регистра характеризуется названным логическим выражением:


**Определение 1.**
(QED-EDDI-V-detectable) Рассмотрим последовательность инструкций произвольной, но конечной длины, которая выполняется на исходном наборе регистров O, начиная с некоторого начального состояния, которое является QED-совместимым, как определено в уравнении 1. Рассмотрим дублирование этой последовательности инструкций, которое выполняется на дублированном наборе регистров D соответственно, как определено через m. Дублированная последовательность выполняется в произвольном чередовании с исходной последовательностью. Логическая ошибка называется QED-EDDI-V-детектируемой тогда и только тогда, когда существует пара таких последовательностей инструкций, что результирующее состояние процессора нарушает согласованность QED, как определено в уравнении 1, после завершения последней записи в регистр в любой из двух последовательностей.
В дальнейшем, для простоты, мы будем говорить о QED и "QED-обнаруживаемых" ошибках, когда будем иметь в виду QED EDDI-V тесты и ошибки, которые могут быть обнаружены QED EDDI-V тестами, соответственно.


**B. Символическое быстрое обнаружение ошибок (SQED)**
SQED [15], [16] объединяет программный тест QED с проверкой ограниченных моделей (Bounded Model Checking, BMC) для поиска последовательностей инструкций, раскрывающих ошибку в проекте. Конечная цель этого подхода - найти QED-совместимый след ошибки минимальной длины с помощью BMC. QED-совместимый след - это QED-тест, начинающийся с QED-совместимого состояния регистра. 
Чтобы использовать BMC, нам нужна модель системы (например, RTL-код аппаратуры), свойство, которое нужно доказать, и начальное состояние, с которого начинается развёрнутая модель. Для SQED необходимо управлять решателем таким образом, чтобы он рассматривал только QED-преобразованные последовательности инструкций. Это достигается путем включения в аппаратное описание процессора специального модуля, называемого QED-модулем, который не добавляется в выпускаемую ИС, а используется только для проверки. Он вставляется между блоком выборки и блоком декодирования и работает следующим образом: Он буферизирует инструкции (и в то же время передает их в блок декодирования) до тех пор, пока не встретится первая инструкция ветвления. Здесь он переключается в "режим дублирования". Он воспроизводит инструкции из своего буфера, тем самым переводя все обращения к регистрам (и обращения к памяти) в дублированные регистры (и ячейки памяти). В конце дублированной последовательности модуль QED выставляет флаг (ged_ready), указывающий на то, что результаты обеих последовательностей наблюдаемы и готовы к сравнению в наборе регистров. С помощью модуля QED рассматриваются только QED-совместимые следы ошибок. Свойство, проверяемое решателем BMC, следующее:


ged_ready - qged_consistent_registers (2)

где ged_ready - флаг, утверждаемый модулем QED в конце последовательности.
BMC стартует из определенного состояния и пытается достичь состояния, нарушающего свойство, за конечное время (кгмк тактов). В SQED начальным состоянием для BMC должно быть состояние регистра, совместимое с QED, как упоминалось выше. Одним из способов получения состояния, совместимого с QED, является симуляция QED-теста и извлечение значений регистров и памяти сразу после выполнения инструкций проверки.
Хотя SQED способен обнаружить некоторые сложные ошибки, которые не могут быть обнаружены обычными методами [15], [16], SQED не может доказать отсутствие какого-либо класса ошибок, таких как логические ошибки, обнаруживаемые EDDI-V, и существуют определенные ошибки, которые могут быть устранены. Это связано с тем, что решатель пытается найти след ошибки, начиная с определенного начального состояния в течение конечного временного окна (кгмк тактов). Для практических проектов не представляется возможным рассматривать временное окно, достаточно большое, чтобы покрыть последовательную глубину дизайна.
В таб. I описан пример ошибки, которую невозможно обнаружить с помощью SQED. Для загрузки соответствующих значений в регистровый файл и активации ошибки требуется длинная последовательность инструкций (и большое временное окно для решателя); однако обычно решатель в SQED не в состоянии исследовать все возможные программы с такими длинными последовательностями инструкций.
Стоит изучить, как можно решить эту проблему с помощью варианта BMC, называемого Interval Property Checking (IPC) [12]. Как и в обычном BMC, IPC разворачивает последовательную схему на конечное число тактов (заданное свойством) и проверяет истинность свойства с помощью SAT. Однако, в отличие от стандартного BMC, начальное состояние разворачивания оставляется в качестве свободного ввода ("доказательство любого состояния").
В некоторых случаях, однако, могут возникать ложные контрпримеры, и доказательства приходится усиливать инвариантами [12]. Коммерческие инструменты верификации обычно содержат механизмы доказательства для автоматической генерации таких инвариантов.


**III. РАСШИРЕНИЯ SQED НА ОСНОВЕ IPC**
На рис. 2 показано свойство SQED из уравнения 2, записанное в виде интервального свойства в псевдокоде. Предположения свойства относятся к выходному сигналу ged_ready модуля QED. Макрос ged_consistent_registers() в доказательстве обязательства инстанцирует логическое выражение уравнения 1. 
Единственное предположение, которое делается о начальном состоянии, - это то, что флаг ged_ready установлен. Доказательство IPC, начинающееся с произвольного, возможно, недостижимого начального состояния, чаще всего будет неудачным, поскольку начальное состояние включает произвольный набор присвоений значений регистрам процессора.
Свойство SQED необходимо переформулировать таким образом, чтобы оно отражало больше внутренней информации о достижимости конвейера. Новая формулировка показана на рис. 3. Неформально она гласит: "Если процессор находится в QED-совместимом состоянии и флаг ged_ready установлен, то, когда флаг ged_ready снова становится установленным, достигается новое QED-совместимое состояние".
Из-за того, что начальное состояние доказательства оставлено в качестве свободного входа, решатель может рассматривать начальное состояние, в котором в конвейере есть несколько частично выполненных инструкций. Эти невыполненные инструкции могут записать в некоторые регистры новые значения, не соответствующие согласованности QED, и в итоге сгенерировать ложный контрпример. Чтобы справиться с этой проблемой, одним из решений является предположение о промывке конвейера в начальном состоянии операции, как показано на рис. 3.
Чтобы внести значимый вклад в посткремниевые проверочные тесты, свойство SQED на рис. 3 должно быть доказано для любого возможного начального состояния и для значений &, достаточно больших, чтобы охватить QED-тесты реалистичного размера. Однако увеличение k резко увеличивает сложность и время выполнения доказательства. Как будет показано в разделе V, для верификации основной части Aquarius невозможно получить результат доказательства от решателя для k > 12 менее чем за 45 часов. Поэтому вместо прямолинейного подхода к включению символического начального состояния в SQED в следующем разделе мы предлагаем новый метод (S2QED), который решает эту проблему и направлен на доказательство свойства SQED рис. 2 только с небольшим количеством разворачиваний, которое может быть выполнено решателем.

**IV. БЫСТРОЕ ОБНАРУЖЕНИЕ ОШИБОК С СИМВОЛИЧЕСКИМ НАЧАЛЬНЫМ СОСТОЯНИЕМ (S2QED)**

**A. Активация и обнаружение ошибок**
Логические ошибки в процессоре могут быть смоделированы в два этапа: 
1. определенная последовательность инструкций, которая активирует ошибку;
2. определенная последовательность инструкций, которая делает ошибку наблюдаемой в бите состояния, видимого программой. В этой модели критерий активации ошибки может быть описан набором состояний, которых достигает проверяемый дизайн в конце последовательности активации ошибки.

В минимальной трассировке ошибки QED в последовательности есть (по крайней мере) одна сбойная инструкция, которая распространяет эффект ошибки в видимые программой регистры; инструкции перед (первой) сбойной инструкцией либо способствуют активации ошибки, либо могут быть опущены из трассировки. Согласно этому определению, длина трассировки ошибки зависит от того, сколько инструкций необходимо для активации ошибки. Однако в S2QED, если разрешить решателю рассматривать все возможные начальные состояния, он сможет стартовать из состояния, которое неявно представляет систему после последовательности активации ошибки.
Следовательно, трассировка ошибок для каждого возможного обнаруживаемого в QED бага может быть всего лишь одной инструкцией при условии, что нет ограничений на начальное состояние доказательства.

**B. Модель верификации S2QED**
Модель верификации, которую мы представляем в этой статье, основана на идее, что исходная и EDDI-V-преобразованная последовательность может выполняться параллельно на двух независимых экземплярах процессора. Согласованность QED в этом случае относится к отображению между регистрами двух экземпляров процессора. Может быть произвольное отображение между именами регистров. Например, если O = {Rj,...,R\} - это набор оригинальных регистров (в экземпляре 1), а D = {R?,...,R%,} - набор дублирующих регистров (в экземпляре 2), и все регистры ведут себя одинаково, то одним из способов определения функции соответствия может быть такой: m(R}) = R3,_,. Обратите внимание, что в S2QED между двумя экземплярами могут быть отображены и специальные регистры, такие как PC и регистры состояния; однако обычно каждый такой специальный регистр в CPU1 должен быть отображен на тот же регистр в CPU 2. S2QED можно включить для проверки потока управления, если расширить проверочное выражение QED_consistent_registers(), сравнив значения PC в двух экземплярах после инструкции ветвления.
Чтобы упростить изложение основной идеи, давайте пока рассмотрим процессор со статическим (in-order) конвейером. Например, рассмотрим классический 5-ступенчатый RISC-конвейер с этапами IF, ID, EX, MEM и WB. На рис. 4 показано свойство, которое необходимо доказать, чтобы доказать отсутствие какого-либо QED-обнаруживаемого бага. Свойство предполагает, что оба экземпляра ЦП получают один и тот же опкод в момент времени tp; инструкция, полученная в ЦП 2, является QED-дублированной версией инструкции, полученной в ЦП 1, с тем же опкодом, но с разными операндами в соответствии с регистровым отображением m. В каждом экземпляре ЦП эта "проверяемая инструкция" (IUV) проходит через конвейер и в конечном итоге записывает свои результаты в регистровый файл на этапе записи в момент времени twp.
Свойство S2QED на рис. 4 не накладывает никаких ограничений на начальное состояние, кроме того, что CPU 2 выполняет QED-копию инструкции в CPU 1, и что предыдущая последовательность инструкций создает QED-согласованный регистровый файл.
В качестве примера посмотрим, как S2QED обнаруживает ошибку на рис. 1. При проверке свойства S2QED из рис. 4 на неисправном конвейере SAT-решатель выдает один из многих корректных контрпримеров. Например, одна из возможных трассировок ошибки может содержать первые три инструкции из этого примера в виде "оригинальной последовательности" на CPU 1 и их дублированные версии на CPU 2. В момент времени typ процессор 1 считывает "проверяемую инструкцию", MOV R1, #3 из строки 3 на рис. 1, а процессор 2 считывает "дублирующую" инструкцию MOV R17, #3 из строки 6 (предполагается, что регистровое отображение такое же, как в примере QED). В контрпримере начальное состояние в момент tp также содержит инструкции из строк | и 2 на этапах EX и ID процессора 1, а также инструкции из строк 4 и 5 на этапах EX и ID процессора 2. Трассировка ошибок показывает, что в более поздний момент времени ¢jpg-1 инструкция из строки 2 записывается обратно в регистровый файл CPU 1, а инструкция из строки 5 записывается обратно в регистровый файл CPU 2. В этот момент времени оба регистровых файла все еще находятся в QED-согласованности друг с другом, как того требует предположение о свойстве. Однако в конвейере процессора 1 (но не в процессоре 2) активизировалась ошибка, и IUV из строки 3 записывает в регистровый файл поврежденное значение в twp, в то время как дублирующая инструкция записывает в свой регистровый файл правильные значения.
Теорема 1. Свойство S2QED на рис. 4 не выполняется для всех QED-EDDI-V-обнаруживаемых логических ошибок (ср. определение 1), для заданного отображения регистров m.

Доказательство. Предположим, что в конструкции процессора есть QED-EDDI-V-обнаруживаемая ошибка. Тогда существует последовательность инструкций |, которая запускается из некоторого QED-совместимого начального состояния и выдает неверный результат в регистрах или ячейках памяти процессора, а также существует другая последовательность инструкций 2 с теми же опкодами, которая выдает другой результат (например, правильный). Если мы сравним наборы регистров после каждой инструкции последовательности 1 с соответствующими наборами регистров последовательности 2 в соответствии с функцией отображения m, как результат Определения 1, мы можем определить одну инструкцию ([UV сверху), для которой регистры/места памяти все еще QED-совместимы до выполнения этой инструкции, но не QED-совместимы после выполнения. Именно эта инструкция распространяет эффект ошибки на видимые программой регистры/места памяти. В дальнейшем мы будем называть ее "наблюдающей инструкцией".
Свойство рис. 4 не выполняется для конструкции процессора, содержащей рассматриваемую ошибку, поскольку существует контрпример, нарушающий это свойство. В этом контрпримере наблюдающая инструкция извлекается по адресу fj в процессоре |, а ее ненаблюдающая дублируется в процессоре 2. На начальное состояние свойства IPC нет никаких ограничений, кроме того, что последовательность инструкций, предшествующая наблюдающей инструкции, не создает QED-несовместимых наборов регистров в CPU1 и CPU2 и что CPU 2 выполняет ту же инструкцию, что и CPU 1, но на основе разных операндов, заданных m. Решатель SAT неявно перечисляет в CPU 1 все возможные инструкции ISA, при всех возможных конфигурациях операндов и режимах адресации. Если существует QED-EDDI-V-обнаруживаемая ошибка, то каждая инструкция, в которой наблюдается эффект ошибки, связанный с активированной ошибкой, приводит к сбою свойства.
Обратите внимание, что в S2QED на самом деле нужно дублировать только проверяемую инструкцию (IUV). Нет причин дублировать также опкоды предшествующих инструкций. Это замечание позволяет модифицировать свойство, что снижает сложность доказательства, но не ухудшает общность результата доказательства: Один из двух экземпляров процессора может быть ограничен для запуска из начального состояния, которое представляет собой конвейер с заранее определенной последовательностью инструкций, например, последовательностью NOP (промытый конвейер). Кроме того, инструкции, следующие за IUV, могут быть ограничены тем, чтобы быть инструкциями NOP в этом ядре.
На рис. 5 показана вычислительная модель S2QED. Мы разворачиваем два экземпляра процессора на несколько временных интервалов. CPU | ограничен стартом из состояния Sref с промытым конвейером, а также извлекает только NOP-инструкции во временных рамках для ¢ > 1. CPU 2 не ограничен в отношении своего начального состояния и всех последующих инструкций. В этой вычислительной модели SAT-решатель сравнивает сценарий 1, в котором IUV выполняется в контексте с промытым конвейером, со всеми возможными сценариями 2, в которых IUV выполняется в произвольном контексте, включая те, в которых активируются и распространяются ошибки. (Если ошибка возникает в контексте промытого конвейера процессора 1, то любой другой контекст дает другой (правильный) результат в процессоре 2, и ошибка также обнаруживается). Ограничение процессора 1 путем фиксации многих входов в виде констант, как показано на рисунке, значительно сокращает время доказательства.
Если конструкция удовлетворяет свойству S2QED, это означает, что в ней нет обнаруживаемых логических ошибок QED-EDDI-V (см. определение 1) для QED-тестов произвольной длины. Это сильное утверждение, которое очень полезно при постсиликоновой валидации: Оно позволяет сделать вывод, что любой неудачный QED-тест при посткремниевой валидации вызван электрической или иной ошибкой, а не ошибкой логического дизайна.
Кроме того, мы можем сделать полезные утверждения в ходе предварительной верификации, как уже упоминалось ранее. Доказательство свойства S2QED позволяет нам заключить для каждой инструкции в ISA, что ее выполнение не зависит от состояния процессора в момент загрузки инструкции.

**C. Обработка внепорядковой записи обратно**
До сих пор в нашем обсуждении для простоты мы предполагали строго статический конвейер. Однако на практике конвейеры процессоров оказываются более сложными. Даже в статических конвейерах моменты времени обратной записи не фиксированы и могут происходить вне очереди (как в случае с процессором Aquarius, на котором мы проводили эксперименты). Поэтому вместо предположения о QED-согласованном регистровом файле на такте, предшествующем завершению IUV (как на рис. 4), мы должны сделать предположение, которое немного сложнее. Мы называем его предположением "QED-последовательный конвейер". Пусть ré - содержимое регистра r в момент времени ¢; w! - сигнал разрешения записи в регистр r в момент времени ¢, 2; - входные данные в регистр r в момент времени ¢, а ¢,,9 - момент времени последней записи в регистр из последовательности инструкций, предшествующей IUV. O и D - оригинальный и дублирующий наборы регистров, соответственно, а m - соответствие между ними, как было определено ранее. Применительно к верификационной модели, показанной на рис. 5, O - это регистровый файл CPU2, а D - регистровый файл CPU 1.

Приведенное выше логическое выражение выводит для практического конвейера условия, представляющие QED-согласованный регистровый файл в результате выполнения инструкций, предшествующих IUV. Основная идея заключается в том, что отдельные пары соответствующих регистров являются QED-согласованными либо если последние записанные в них значения равны, либо, если ничего не было записано, они были равны в начале рассматриваемого временного окна. Верхняя часть (уравнение 3a) для каждого регистра исходного набора утверждает, что содержимое регистра в момент времени fo такое же, как и в дублирующем наборе, либо в конвейере есть какая-то ожидающая инструкция, позволяющая записать в этот регистр в какой-то более поздний момент. Нижняя часть (уравнение 3b) определяет, что если в какой-то момент времени ¢ разрешена запись в регистр, то записанное значение совпадает с соответствующим значением в CPU 1, либо в этот регистр разрешена другая запись в какой-то момент времени позже t.

На рис. 6 показано свойство S2QED, которое необходимо доказать. twb1 - момент времени обратной записи в IUV. По сравнению со свойством SQED на рис. 3 с предположением о промывке конвейера, для формулировки состояния конвейера, соответствующего QED, требуется больше информации "белого ящика" о микроархитектуре процессора. Однако получить эту информацию из белого ящика довольно просто. Для этого нужно определить набор всех сигналов разрешения записи для данных, поступающих в файл регистров общего назначения и другие видимые программой регистры из конвейера процессора. Кроме того, необходимо определить моменты времени twb и twb обратной записи для IUV и инструкции, предшествующей IUV, соответственно. Это можно сделать на основе нескольких управляющих сигналов конвейера, например, управляющих срывом. Определения временных точек не обязательно должны быть постоянными и могут быть сформулированы для каждого регистра. Это позволяет приспособиться к внепорядковой записи.

**V. ЭКСПЕРИМЕНТАЛЬНЫЕ РЕЗУЛЬТАТЫ**
Эффективность S2QED показана на примере проверки функциональной корректности по отношению к QED-обнаруживаемым ошибкам Aquarius, 32-битного процессора с открытым исходным кодом со статическим конвейером и внепорядковым завершением, основанного на архитектуре набора инструкций (ISA) SuperH2 [18]. 18 различных сценариев логических ошибок из [16], [17], а также ошибка, описанная в табл. I, были внедрены в RTL-код Aquarius. Эти сценарии ошибок встречались в различных коммерческих процессорах и SoC, и известно, что их сложно обнаружить и локализовать [16], [17]. Для проверки свойств IPC мы использовали коммерческий инструмент Onespin 360 DV-Verify на процессоре Intel Xeon E5-2660 с 32 ГБ оперативной памяти, работающем на частоте 2,20 ГГц.
Для сравнения с оригинальным подходом SQED мы оснастили блок выборки процессора Aquarius модулем QED, как описано в [16]. (Отметим, что в отличие от SQED метод S2QED не требует инструментации или модификации RTL-кода). Мы вставили в Aquarius логические ошибки из [16], [17], которые ранее были обнаружены на различных аппаратных платформах с помощью оригинальной методики SQED [16]. Мы обнаружили все эти ошибки с помощью S2QED, затратив на каждую из них менее одной минуты вычислительного времени. 

В таб. II суммирует полученные результаты. В этой таблице каждый столбец представляет собой отдельный метод верификации, примененный к Aquarius. Aquarius был формально верифицирован с помощью современной формальной проверки свойств по промышленной методологии [11], [12]. Это представлено в первом столбце. Второй столбец соответствует SQED, который использует BMC в качестве метода доказательства. В таб. II "Количество усилий" относится к ручной работе, проделанной инженером по верификации для разработки верификационной установки и свойства. "Время выполнения" относится к вычислениям, затраченным на обнаружение ошибки или доказательство ее отсутствия. В случае ошибки также указывается длина контрпримера. Очевидно, что доказать корректность свойства для решателей обычно сложнее, чем опровергнуть его и найти контрпример.

Таб. III посвящена времени выполнения и требованиям к памяти для SQED и S2QED. В первой строке мы показываем, что прямой подход к интегрированию символьного начального состояния, как на рис. 3, не является простым. Затем мы сравниваем нашу реализацию SQED с S2QED. Для сравнения SQED и S2QED следует отметить, что вычислительная модель S2QED представляет дублированную последовательность инструкций параллельно (см. рис. 5), в то время как обычная SQED, благодаря своему модулю QED, представляет те же последовательности последовательно друг за другом. Поэтому с точки зрения размера модели k = 7 разворачиваний в S2QED соответствует k = 14 разворачиваниям в SQED. Для S2QED было выбрано временное окно в k = 7 тактов, поскольку этого достаточно для формального доказательства отсутствия QED-обнаруживаемых ошибок, так как каждая инструкция может завершить выполнение за этот промежуток времени. Большее окно не нужно и никак не усилит доказательство. Однако в SQED сила метода зависит от длины временного окна. Поэтому мы исследуем SQED с разным количеством разворачиваний.
На основе двух приведенных выше таблиц можно сделать следующие выводы: 
Наблюдение 1: S2QED может за разумное время обнаружить все ошибки, которые можно обнаружить с помощью оригинального метода SQED. Он также может обнаружить ошибки с большими задержками обнаружения ошибок, например, ошибку, описанную в табл. I, для активации которого требуется последовательность из 14 инструкций, а след ошибки состоит только из одной инструкции. Учитывая, что оригинальный SQED не может обнаружить этот класс ошибок, данная функция значительно улучшает проверочные возможности S2QED. Поскольку длина следа ошибки сильно влияет на сложность доказательства, возможность находить сложные ошибки с очень коротким следом ошибки делает метод более масштабируемым для больших конструкций.
Наблюдение 2: Как было описано в предыдущих разделах, S2QED вносит ценный вклад в предварительную верификацию, доказывая, что каждая инструкция ведет себя независимо от своего контекста в программе. Ошибки, избежавшие этой проверки, будут одинаково проявляться в любом контексте, и поэтому, как отмечается в [9], можно ожидать, что они будут легко обнаружены даже методами, основанными на моделировании. Поскольку не требуется задавать золотую модель ISA, S2QED позволяет получить этот важный результат верификации с существенно меньшими затратами ручного труда по сравнению с классической верификацией процессора путем проверки свойств (10 человеко-часов по сравнению с 3 человеко-месяцами).
Наблюдение 3: S2QED не требует модификации RTL-кода проекта и не имеет ограничений на инструкции, которые он может рассматривать, в отличие от оригинального SQED, который не может рассматривать некоторые инструкции, использующие операнды, отличные от регистров общего назначения, например, регистры состояния. Установку проверки можно повторно использовать для исправленных или модифицированных версий процессорного ядра, если не изменены программно видимые регистры в конструкции.

**VI. ЗАКЛЮЧЕНИЕ**
В статье представлен S2QED - формальный метод, позволяющий находить все обнаруживаемые QED логические ошибки в процессорных ядрах во время предварительной верификации. Это значительное улучшение по сравнению с предыдущим методом SQED. В отличие от SQED, S2QED также вносит вполне определенный вклад в предварительную верификацию: он доказывает, что результат выполнения каждой инструкции не зависит от ее контекста в программе. Метод требует значительно меньше ручных усилий по сравнению с предыдущими методами проверки свойств.
Благодаря нашему понятию QED-совместимого конвейера, сформулированному в уравнении 3 раздела IV-C, предложенный подход оказался полезным для процессоров с внепорядковой записью-возвратом. Однако для полностью динамических процессоров с внеочередным выполнением и буферами переупорядочивания наш подход будет ограничен из-за большой глубины последовательности. Таким образом, улучшение проходимости для таких случаев является предметом нашей будущей работы.

</font>