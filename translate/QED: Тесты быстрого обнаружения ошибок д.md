<font face = "Times New Roman" size = 5 color = black > 


**QED: Тесты быстрого обнаружения ошибок для эффективной посткремниевой проверки**
QED: Quick Error Detection Tests for Effective Post-Silicon Validation

**Аннотация**
Длительная задержка обнаружения ошибок - время, проходящее между возникновением ошибки, вызванной багом, и ее проявлением в виде сбоя на уровне системы, - является одной из основных проблем при посткремниевой валидации надежных систем. В этой статье мы представляем новую технику под названием Quick Error Detection (QED), которая преобразует существующие посткремниевые тесты проверки в новые тесты проверки, которые значительно сокращают время обнаружения ошибок. Преобразования QED позволяют гибко выбирать между задержкой обнаружения ошибок, покрытием и сложностью, и могут быть реализованы в программном обеспечении с минимальными изменениями в аппаратной части или вообще без них. Результаты, полученные в ходе аппаратных экспериментов на четырехъядерных аппаратных платформах Intel® Core™ i7 и в ходе моделирования на многоядерном процессоре MIPS, демонстрируют, что:
1. QED значительно улучшает задержки обнаружения ошибок на шесть порядков, т.е. с миллиардов циклов до нескольких тысяч циклов или меньше. 
2. Преобразования QED не ухудшают охват тестов проверки, что оценивается эмпирически путем измерения максимальных рабочих частот в широком диапазоне рабочих точек напряжения.
3. QED-тесты улучшают покрытие за счет обнаружения ошибок, которые ускользают от исходных не QED-тестов. 

**1 Введение**
Целью посткремниевой валидации является тестирование произведенных чипов в реальных системах, чтобы гарантировать, что никакие ошибки не попадут в полевые условия. Проводится широкий спектр тестов - тесты случайных инструкций, тесты, ориентированные на конкретную архитектуру, и приложения для конечных пользователей, такие как операционные системы, игры и научные приложения [Intel 03], - во время которых отслеживается реакция системы на аномальное поведение, такое как сбои, зависания, исключения или неправильные результаты. Любая замеченная аномалия отлаживается для определения ее причины. Усилия по отладке на основе наблюдаемых сбоев доминируют в общем объеме посткремниевой проверки процессоров [Josephson 06], особенно в случае неуловимых электрических ошибок. Электрические ошибки проявляются только при определенных условиях работы (напряжение, частота и/или температура) [Patra 07] и могут быть вызваны недостатками конструкции, проблемами синхронизации, шумами и т. д. Очень важно обнаружить эти ошибки быстро после их проявления, чтобы обеспечить эффективную отладку.
Задержка обнаружения ошибок - время, проходящее между возникновением ошибки, вызванной багом, и ее обнаружением в наблюдаемой точке тестовой программы - может достигать нескольких миллиардов циклов. Длительное время обнаружения ошибок ограничивает эффективность существующих методов посткремниевой отладки, основанных на моделировании, формальном анализе и трассировке. Моделирование на порядки медленнее реального кремния [Olukotun 98], формальный анализ на протяжении более чем сотен циклов может быть затруднен [Ho 09], а трассировка ограничена наличием памяти на кристалле [Abramovici 06]. Кроме того, длительные задержки обнаружения ошибок могут привести к увеличению маскировки ошибок, т. е. ошибка может не распространиться до наблюдаемой точки.
Взаимодействие между ядрами в многоядерных системах-на-чипе (SoC) может привести к чрезвычайно большим задержкам обнаружения ошибок. Например, предположим, что ошибочное значение, вызванное электрической ошибкой в ядре 1, сохраняется в общей памяти (рис. 1). Может пройти несколько миллионов циклов, прежде чем ядро, свободное от ошибки (ядро 2 на рис. 1), загрузит и обработает ошибочное значение, что приведет к сбою системы. Время от хранения ядра 1 до загрузки ядра 2 - межъядерная задержка хранения-загрузки - является нижней границей задержки обнаружения ошибки. Для распространения ошибки до наблюдаемой точки в тестовой программе могут потребоваться дополнительные циклы, включая дополнительные межъядерные и внутриядерные сохранения и загрузки. На рисунке 2 представлены распределения межъядерных задержек хранения и загрузки для двух репрезентативных программ из набора эталонов Splash2 [Woo 95], выполненных на симулированном 4-ядерном 4-полосном процессоре MIPS [Renau 05]. Для FMM более 82 % всех задержек между ядрами при хранении и загрузке превышают один миллион циклов, а более 97 % - более 100 тысяч циклов. Как уже говорилось ранее, такие большие задержки обнаружения ошибок очень сложны для посткремниевой отладки.
В данной статье представлены тесты быстрого обнаружения ошибок или OED-тесты для преодоления проблемы задержки обнаружения ошибок при посткремниевой валидации процессоров. Тесты QED получаются путем преобразования существующих тестов посткремниевой валидации в новые тесты со значительно меньшими (т. е. лучшими) задержками обнаружения ошибок. Тесты QED могут быть выполнены с помощью различных преобразований OED, требующих только программных или только аппаратно-программных изменений. Кроме того, преобразования QED позволяют гибко выбирать между задержкой обнаружения ошибок, покрытием (т.е. процентом ошибок, обнаруженных тестовой программой) и сложностью (т.е. дополнительными аппаратными и программными модификациями, необходимыми для QED). Целевые задержки обнаружения ошибок настраиваются и могут составлять от нескольких циклов до нескольких тысяч циклов, в зависимости от желаемых компромиссов.
Эта статья посвящена электрическим жучкам по трем причинам:
1. Отладка электрических ошибок часто занимает очень много времени [Josephson 01].
2. Электрические ошибки можно смоделировать как битовые перевороты на флип-флопах. Это эффективная модель, поскольку большинство электрических ошибок в конечном итоге проявляются в виде неправильных значений, поступающих на флип-флопы [McLaughlin 09]. Существование таких моделей электрических ошибок позволяет проводить имитационные эксперименты.
3. В отношении моделей логических ошибок не существует единого мнения [ITRS 09].

Результаты, полученные в ходе аппаратных экспериментов и моделирования, показывают, что:
1. QED значительно улучшает задержки обнаружения ошибок на шесть порядков, с миллиардов циклов до нескольких тысяч циклов или меньше. При таких коротких задержках обнаружения ошибок ошибки в процессорных ядрах обнаруживаются очень быстро и могут быть эффективно проанализированы с помощью таких методов отладки, как IFRA [Park 09], Backspace [De Paula 08] и буферов трассировки [Abramovici 06].
2. QED-преобразования не ухудшают охват тестов на проверку, что подтверждается эмпирическими измерениями значений Fmax - максимальных значений рабочей частоты в широком диапазоне точек рабочего напряжения [Josephson 02].
3. QED-тесты улучшают покрытие за счет обнаружения ошибок, которые ускользают от исходных не QED-тестов. Покрытие часто ограничивается молчаливыми ошибками и замаскированными ошибками. Тихая ошибка возникает, когда ошибка вызывает ошибку, которая распространяется в наблюдаемую точку, но недостаточная проверка пропускает ошибку. Маскированная ошибка возникает, когда ошибка вызывает ошибку, которая не распространяется в наблюдаемую точку (Barton 90]. Поскольку всесторонние проверки осуществляются с помощью QED-преобразований, количество молчаливых и маскируемых ошибок может быть значительно сокращено.

Основными вкладами данной работы являются:
1. Представление идеи QED для посткремниевой валидации процессоров.
2. Экспериментальные результаты, полученные на четырехъядерных платформах Intel® Core™ i7, демонстрирующие снижение (т.е. улучшение) на шесть порядков латентности обнаружения ошибок с помощью QED. Эти результаты также подтверждены детальным моделированием 4-ядерного 4-полосного процессора MIPS. 
3. Эмпирические экспериментальные результаты, полученные на наших аппаратных платформах, демонстрирующие, что тест QED может обнаружить почти в 4 раза больше ошибок по сравнению с тестом, использующим только проверки конечных результатов, которые сравнивают фактические результаты работы программы с ожидаемыми.
4. Эмпирический анализ влияния QED-тестов на покрытие, измеряемое Fmax, показывает, что: 
а) QED-тесты не ухудшают покрытие и 
б) QED-тесты улучшают покрытие. Эти результаты демонстрируются с помощью графиков Шму, охватывающих широкий диапазон рабочих точек напряжения и частоты, полученных с наших аппаратных платформ.
В разделе 2 представлены QED-преобразования. В разделе 3 представлены эксперименты на основе аппаратных средств и моделирования, а также экспериментальные результаты, демонстрирующие эффективность QED. В разделе 4 представлены сопутствующие работы, а в разделе 5 - выводы и дальнейшая работа.

**2 Преобразования QED**
Идея QED вдохновлена одновременным обнаружением ошибок, используемым в отказоустойчивых вычислениях, например, [Lu 82, Mahmood 88, Oh 02a, 02b, Rotenberg 99, Saxena 00]. Однако посткремниевая проверка предъявляет уникальные требования и возможности, отличные от отказоустойчивых вычислений:
1. В отличие от отказоустойчивых вычислений, тесты посткремниевой проверки не требуют локализации и восстановления сбоев.
2. В отличие от отказоустойчивых вычислений, где для уменьшения потерь производительности обычно предпочитаются проверки "высокого уровня", при посткремниевой валидации некоторые потери производительности могут быть приемлемыми. Напротив, минимизация задержки обнаружения ошибок имеет первостепенное значение, поскольку время отладки, а не время выполнения теста является основным узким местом.
3. При посткремниевой валидации входные данные тестовой программы могут быть известны заранее (Bentley O1]. Это дает уникальную возможность для агрессивной проверки: QED-преобразования могут быть оптимизированы для соответствующих тестовых входов.
4. Преобразования для тестов после кремниевой валидации не должны отрицательно влиять на покрытие.

По сравнению с отказоустойчивыми вычислениями, первые три аспекта предполагают, что преобразования QED могут быть "проще". Однако последнее ограничение требует, чтобы преобразования QED обеспечивали достаточную гибкость, чтобы избежать ухудшения покрытия.
Эта статья посвящена электрическим жучкам по трем причинам:
1. Отладка электрических ошибок часто занимает очень много времени [Josephson 01].
2. Электрические ошибки можно смоделировать как битовые перевороты на флип-флопах. Это эффективная модель, поскольку большинство электрических ошибок в конечном итоге проявляются в виде неправильных значений, поступающих на флип-флопы [McLaughlin 09]. Существование таких моделей электрических ошибок позволяет проводить имитационные эксперименты.
3. В отношении моделей логических ошибок не существует единого мнения [ITRS 09].

Результаты, полученные в ходе аппаратных экспериментов и моделирования, показывают, что:
1. QED значительно улучшает задержки обнаружения ошибок на шесть порядков, с миллиардов циклов до нескольких тысяч циклов или меньше. При таких коротких задержках обнаружения ошибок ошибки в процессорных ядрах обнаруживаются очень быстро и могут быть эффективно проанализированы с помощью таких методов отладки, как IFRA [Park 09], Backspace [De Paula 08] и буферов трассировки [Abramovici 06].
2. QED-преобразования не ухудшают охват тестов на проверку, что подтверждается эмпирическими измерениями значений Fmax - максимальных значений рабочей частоты в широком диапазоне точек рабочего напряжения [Josephson 02].
3. QED-тесты улучшают покрытие за счет обнаружения ошибок, которые ускользают от исходных не QED-тестов. Покрытие часто ограничивается молчаливыми ошибками и замаскированными ошибками. Тихая ошибка возникает, когда ошибка вызывает ошибку, которая распространяется в наблюдаемую точку, но недостаточная проверка пропускает ошибку. 
Маскированная ошибка возникает, когда ошибка вызывает ошибку, которая не распространяется в наблюдаемую точку [Barton 90]. Поскольку всесторонние проверки осуществляются с помощью QED-преобразований, количество молчаливых и маскируемых ошибок может быть значительно сокращено.

Основными вкладами данной работы являются:
1. Представление идеи QED для посткремниевой валидации процессоров.
2. Экспериментальные результаты, полученные на четырехъядерных платформах Intel® Core™ i7, демонстрирующие снижение (т.е. улучшение) на шесть порядков латентности обнаружения ошибок с помощью QED. Эти результаты также подтверждены детальным моделированием 4-ядерного 4-полосного процессора MIPS. 
3. Эмпирические экспериментальные результаты, полученные на наших аппаратных платформах, демонстрирующие, что тест QED может обнаружить почти в 4 раза больше ошибок по сравнению с тестом, использующим только проверки конечных результатов, которые сравнивают фактические результаты работы программы с ожидаемыми.
4. Эмпирический анализ влияния QED-тестов на покрытие, измеряемое Fmax, показывает, что а) QED-тесты не ухудшают покрытие и б) QED-тесты улучшают покрытие. Эти результаты демонстрируются с помощью графиков Шму, охватывающих широкий диапазон рабочих точек напряжения и частоты, полученных с наших аппаратных платформ.
В разделе 2 представлены QED-преобразования. В разделе 3 представлены эксперименты на основе аппаратных средств и моделирования, а также экспериментальные результаты, демонстрирующие эффективность QED. В разделе 4 представлены сопутствующие работы, а в разделе 5 - выводы и дальнейшая работа.

**2 Преобразования QED**
Идея QED вдохновлена одновременным обнаружением ошибок, используемым в отказоустойчивых вычислениях, например, [Lu 82, Mahmood 88, Oh 02a, 02b, Rotenberg 99, Saxena 00]. Однако посткремниевая проверка предъявляет уникальные требования и возможности, отличные от отказоустойчивых вычислений:
1. В отличие от отказоустойчивых вычислений, тесты посткремниевой проверки не требуют локализации и восстановления сбоев.
2. В отличие от отказоустойчивых вычислений, где для уменьшения потерь производительности обычно предпочитаются проверки "высокого уровня", при посткремниевой валидации некоторые потери производительности могут быть приемлемыми. Напротив, минимизация задержки обнаружения ошибок имеет первостепенное значение, поскольку время отладки, а не время выполнения теста является основным узким местом.
3. При посткремниевой валидации входные данные тестовой программы могут быть известны заранее (Bentley O1]. Это дает уникальную возможность для агрессивной проверки: QED-преобразования могут быть оптимизированы для соответствующих тестовых входов.
4. Преобразования для тестов после кремниевой валидации не должны отрицательно влиять на покрытие.

По сравнению с отказоустойчивыми вычислениями, первые три аспекта предполагают, что преобразования QED могут быть "проще". Однако последнее ограничение требует, чтобы преобразования QED обеспечивали достаточную гибкость, чтобы избежать ухудшения покрытия.
В следующих двух разделах представлены два семейства QED-преобразований. Оба семейства основаны на концепции дублирования инструкций и сравнении результатов, выдаваемых оригинальным и дублированным кодом. При надлежащей детализации дублирования и проверки инструкций ошибки, вызванные ошибками, могут быть быстро обнаружены, при условии, что оригинальный и дублированный блоки инструкций не одинаково затронуты ошибками. Для прерывистых электрических ошибок маловероятно, что одна и та же ошибка проявится в двух разных исполнениях одного и того же кода [Patra 07]. Концепция QED может быть расширена для уменьшения вероятности идентичных эффектов ошибок путем выполнения оригинальных и дублированных блоков кода "по-разному" за счет включения разнообразия дизайна в QED (например, за счет разнообразия данных, времени или алгоритмов) [Mitra 02, Oh 02b]. Всесторонняя оценка таких QED, улучшенных за счет разнообразия, выходит за рамки данной статьи.

**2.1 Обнаружение ошибок с помощью дублирования инструкций для проверки (EDDI-V)**
Обнаружение ошибок с помощью дублированных инструкций для проверки (EDDI-V) - это QED-преобразование, которое расширяет технику EDDI, используемую в отказоустойчивых вычислениях [Oh 02a]. EDDI-V ограничивает целевую задержку обнаружения ошибок и предоставляет возможность настройки для компромисса между целевой задержкой обнаружения ошибок и меньшей интрузивностью. Здесь интрузивность определяется как величина "отклонения" в поведении выполнения теста QED от поведения исходного теста (из-за включения QED). EDDI-V не требует аппаратных модификаций и может быть автоматизирован.
EDDI-V стратегически дублирует инструкции и сравнивает их результаты. Как показано на рис. 3, каждый "блок" инструкций дублируется и вставляется проверка для сравнения результатов двух блоков. Если проверка обнаруживает какую-либо ошибку, возникающую в этих блоках, то задержка обнаружения ошибки ограничивается суммой двух членов:
1. Время, прошедшее между началом оригинального блока и концом дублированного блока.
2. Время, необходимое для выполнения проверки.
Это может значительно сократить время обнаружения ошибок по сравнению с исходной программой, которая может обнаружить ошибки только после видимого сбоя (например, сбоя программы) или с помощью своих оригинальных проверок (если они доступны, например, с помощью проверок конечных результатов, которые сравнивают фактические результаты работы программы с ожидаемыми). EDDI-V и EDDI имеют разные компромиссы и требования. В EDDI соблюдается баланс между влиянием на производительность и необходимостью сдерживания и восстановления ошибок. В результате перед каждой инструкцией сохранения и ветвления вставляются дублирующие инструкции и проверки [Oh 02a]. Для посткремниевой проверки влияние частых проверок EDDI- V на производительность не является первоочередной задачей. Вместо этого мы поддерживаем гибкую конфигурацию EDDI-V, чтобы компенсировать задержку обнаружения ошибок за меньшую навязчивость. Это достигается путем изменения двух параметров: Imst_min и Inst_max, которые соответствуют минимальному и максимальному количеству исходных инструкций, выполняемых перед выполнением любых инструкций, вставленных QED (/nst_min должно быть меньше или равно Inst_max по определению). Увеличение Imst_min уменьшает интрузивность, и наоборот. Уменьшение Inst_max увеличивает задержку обнаружения целевой ошибки, и наоборот. Обратите внимание, что, в отличие от Jnst_max, которое всегда может быть удовлетворено, Inst_min - это "мягкое ограничение": хотя мы прилагаем все усилия, чтобы удовлетворить Inst_min, в некоторых случаях это невозможно. Например, Inst_min не может быть удовлетворено, если исходный код содержит меньше Jnst_min инструкций.
EDDI-V реализуется путем резервирования половины регистров общего назначения и пространства памяти для оригинальных инструкций, в то время как другая половина используется дублирующими инструкциями. Например, на рис. 4a две оригинальные инструкции в основной части кода используют четыре регистра (A, B, C и D). Эти две инструкции дублируются, и дублированные инструкции используют другой набор регистров (A', B', C' и D'). В ситуациях, когда регистров недостаточно, значения могут временно храниться в памяти, которая также разделена на две половины для использования оригинальной и дублированной инструкциями соответственно. Значения, хранящиеся в памяти, затем повторно загружаются для сравнения (рис. 4b). Отметим, что даже при большом Inst_min некоторая интрузивность может сохраняться из-за влияния вышеуказанных изменений кода. Каждая половина регистров общего назначения и пространство памяти инициализируются одинаково, чтобы оригинальные и дублированные инструкции выполняли одинаковые операции и получали одинаковые результаты в системе, свободной от ошибок. Проверка выполняется путем сравнения результатов выполнения оригинальных инструкций и их дубликатов. В случае арифметических и логических операций сравнивается содержимое регистров назначения в оригинальной и дублированной инструкциях; в случае операций доступа к памяти сравниваются значения, загруженные из памяти или сохраненные в ней. Любое несовпадение при сравнении указывает на ошибку.
Специальный анализ требуется для некоторых структур кода, таких как циклы, условные сигналы и примитивы синхронизации, например блокировки. Например, небольшой цикл может содержать меньше инструкций, чем требуемое значение Inst_min. В этом случае цикл разворачивается таким образом, что несколько итераций выполняются без промежуточных ветвлений. Таким образом, можно построить большие блоки, состоящие из инструкций больше Jmst_min и меньше Inst_max. Затем эти блоки дублируются и в них вставляются проверки. Аналогично, может оказаться невозможным разделить тело цикла, содержащее более Inst_max инструкций, на блоки, каждый из которых содержит более Inst min инструкций. В этом случае цикл также можно разворачивать до тех пор, пока не удастся разделить тело цикла на блоки, удовлетворяющие требуемому Imst_min. На рисунке 5 показан пример разворачивания цикла, где Jmst_min = Inst_max = 4. В исходном коде тело цикла содержит всего две инструкции, что меньше Jnst_min. Его разворачивают, чтобы тело цикла содержало четыре инструкции. Развернутое тело цикла дублируется, и в него вставляются проверки. Для условий мы рассматриваем каждый путь выполнения (включая пути любых вложенных условий) отдельно и разбиваем инструкции каждого пути на блоки инструкций, удовлетворяющие Inst_min и Inst_max. Обратите внимание, что для создания таких блоков нам может потребоваться скопировать или переместить некоторые инструкции до или после условия в каждый путь выполнения условия. Что касается блокировок, то мы гарантируем, что оригинальный и дублированный блоки кода защищены одной и той же блокировкой. В случае, когда примитивы синхронизации реализованы с помощью пользовательского кода, может потребоваться некоторое ручное вмешательство.

2.2 Избыточная многопоточность для проверки (RMT-V)
Избыточная многопоточность для проверки (RMT-V) - это еще одно QED-преобразование, вдохновленное отказоустойчивыми вычислениями (Mukherjee 02, Rotenberg 99, Saxena 98, 00, Wang 07]. В отличие от EDDI-V, который выполняет оригинальные, дублированные и проверочные инструкции в одном потоке, RMT-V выполняет оригинальные инструкции в одном потоке и использует дополнительный поток для выполнения дублированных и проверочных инструкций. Два потока RMT-V могут одновременно выполняться на разных ядрах. В результате на выполнение исходных инструкций потенциально меньше влияет выполнение дублированных и проверочных инструкций по сравнению с EDDI-V, что означает меньшую навязчивость. Как и EDDI-V, RMT-V также обеспечивает гибкую конфигурацию для компромисса между задержкой обнаружения целевых ошибок и интрузивностью.

RMT-V реализуется путем создания двух копий исходного тестового кода: основного и проверочного потоков. Основной поток, содержащий оригинальные инструкции, оснащается дополнительными инструкциями для передачи результатов в проверочный поток. Проверочный поток, содержащий дублированные инструкции, оснащен дополнительными инструкциями для получения результатов основного потока и сравнения их с собственными результатами. Обмен данными происходит через очереди FIFO, которые могут быть реализованы программно или аппаратно; для каждой пары основного и контрольного потоков требуется отдельная очередь. Рисунок 6 иллюстрирует механизм RMT-V. В этом примере основной поток выполняет блок из трех инструкций, заносит его результаты (J и K) в очередь и продолжает работать дальше, поскольку нет необходимости в сдерживании ошибок. Проверяющий поток параллельно выполняет свой дублированный блок, а затем отменяет загрузку двух значений для сравнения с собственными результатами. Существуют методы, позволяющие гарантировать, что ни основной, ни проверочный потоки не будут выполняться слишком далеко друг от друга [Mukherjee 02, Rotenberg 99]. Например, проверочный поток может ускорить свое выполнение, используя результаты, переданные из основного потока (таким образом можно устранить некоторые зависимости в выполнении проверочного потока, что позволит выполнять больше инструкций параллельно). Таким образом, целевая задержка обнаружения ошибок в RMT-V, как показано на рис. 7, ограничена суммой двух задержек:
1. Времени, которое требуется главному потоку для выполнения блока инструкций. 
2. Задержка после проверки результатов блока контрольным потоком, которая равна сумме времени, затраченного основным потоком на получение результатов, времени ожидания результатов в очереди и времени, затраченного контрольным потоком на выполнение проверок.
RMT-V может быть гибко настроен на компромисс между навязчивостью и целевой задержкой обнаружения ошибок путем изменения трех параметров: 
1. Inst_min и Inst_max, минимальное и максимальное количество инструкций, выполняемых до возникновения очереди, соответственно. Влияние изменения этих двух параметров на навязчивость и задержку обнаружения целевых ошибок такое же, как описано в разделе 2.1 для EDDI-V. Заметим, что даже при большом Inst_min некоторая интрузивность может сохраняться, поскольку основной поток все равно может быть подвержен возмущениям со стороны проверяющего потока, например, через общий кэш.
2. Накладные расходы на передачу - количество инструкций, необходимых для зачисления одного значения регистра в FIFO. Для передачи каждого проверяемого значения регистра из основного потока в поток проверки требуется один запрос. Более низкие накладные расходы на передачу означают, что QED прерывает поток исходного теста на меньшее время для каждой проверки, что приводит к потенциально меньшей навязчивости при сохранении целевой задержки обнаружения ошибок.
Накладные расходы на передачу могут составлять от нескольких инструкций (RMT-V без какой-либо аппаратной поддержки) до нуля (RMT-V_ с небольшими аппаратными модификациями). Ниже мы представляем три возможных варианта реализации RMT-V: от программных до аппаратных. Сравнение этих трех методов представлено в таблице 1.
Программный RMT-V (S-RMT-V): RMT-V может быть полностью реализована программно с небольшими накладными расходами на передачу данных, состоящими из трех инструкций для каждой операции enqueue: инструкции add для увеличения указателя на следующее свободное место в очереди и двух инструкций store, которые сохраняют данные в очереди и помечают их как действительные. Наша реализация использует идею очередей без блокировок [Michael 96] и не требует никаких блокировок для доступа к очередям FIFO.
S-RMT-V с аппаратными очередями (S-RMT-V-HQ): При использовании очередей, реализованных в виде аппаратных FIFO (рис. 8), накладные расходы на передачу могут быть сведены к одной инструкции сохранения для каждой операции enqueue: одна инструкция сохранения может указать значение для передачи в своем поле данных и FIFO назначения в своем поле адреса. Для реализации FIFO необходимы небольшие аппаратные модификации, но процессорные ядра не нуждаются в изменениях, поскольку доступ к FIFO осуществляется через ввод-вывод с привязкой к памяти.
Аппаратный RMT-V (H-RMT-Y): Навязчивость QED может быть значительно снижена за счет аппаратной реализации RMT-V - поскольку в основной поток H-RMT-V не вставляются дополнительные инструкции, выполнение основного потока будет "похоже" на выполнение исходного тестового потока, хотя небольшие отклонения между выполнением двух потоков все же возможны из-за эффектов кэша, недетерминированных событий (например, прерываний) и так далее. Для реализации H-RMT-V каждое ядро дополнено монитором (рис. 8), который автоматически регистрирует результаты выполнения инструкций, подлежащих проверке. Монитор, подобный тому, что используется в [Mahmood 88, Nakka 04], наблюдает за зафиксированными инструкциями, определяет, должна ли какая-либо инструкция быть проверена (например, монитор может быть реализован для проверки каждой инструкции store, или каждой второй инструкции add, и т. д.), и, если да, напрямую посылает команду enqueue в соответствующий аппаратный FIFO. Это приводит к нулевым накладным расходам на передачу.


3. Эксперименты и результаты аппаратного и имитационного моделирования
Ключевыми метриками для оценки QED являются задержка обнаружения ошибок и покрытие. Обе эти метрики очень сложно измерить аппаратно. Без сложного отладочного оборудования крайне сложно определить точный момент времени, когда происходит ошибка. Аналогично, очень сложно определить, изменяет ли тест QED внутреннее электрическое состояние системы таким образом, что это может негативно повлиять на покрытие по сравнению с исходным тестом.


3.1. Эксперименты и результаты на аппаратном обеспечении
На рисунке 9 показана платформа с четырехъядерным процессором Intel® Core™ i7, использованная для оценки QED. BIOS материнской платы DX58SO используется для изменения рабочего напряжения и частоты процессора. Для поддержания фиксированной температуры корпуса микросхемы используется разработанный на заказ терморегулятор. Отладочный инструмент, подключенный к отладочному порту системы, используется для контроля и наблюдения за состоянием системы (например, содержимое регистров и памяти, а также значения рабочего напряжения и частоты).


3.11 Эксперимент по измерению задержки обнаружения ошибок
Сложность измерения задержек обнаружения ошибок в аппаратной платформе заключается в невозможности определить точный момент времени, когда происходит ошибка. Чтобы преодолеть эту проблему, мы создаем окно уязвимости, в течение которого создаются условия для возникновения ошибок. Начало этого окна служит нижней границей того, когда ошибка (если таковая возникнет) действительно произойдет, что позволяет нам получить задержку от инъекции до обнаружения - время между началом окна уязвимости и обнаружением ошибки. Задержка от инъекции до обнаружения является верхней границей (т.е. пессимистичной) для задержки обнаружения ошибки.
Изменяя значения частоты, напряжения и температуры, мы сначала определили условия, при которых система будет работать с ошибками и без них. Запрограммировав нужные параметры с помощью отладочного инструмента, мы создали окно уязвимости, временно переключаясь из состояния, в котором система работает без ошибок (т.е. надежное рабочее состояние), в состояние, в котором могут возникнуть ошибки (т.е. ненадежное рабочее состояние), и обратно. Таким образом, любая ошибка должна произойти во время окна уязвимости, которое длится не более нескольких сотен миллионов циклов.
В нашем эксперименте с "окном уязвимости" надежные и ненадежные условия работы (пары напряжение-частота) были выбраны как (1,02 В, 1,6 ГГц) и (1,02 В, 3,2 ГГц), соответственно, а температура корпуса была зафиксирована на 30°C. Надежный режим работы был выбран с большим запасом по частоте, чтобы обеспечить безошибочную работу системы, а частота ненадежного режима работы была выбрана лишь немного выше частоты, которую процессор может надежно поддерживать при напряжении 1,02 В. При фиксации напряжения на уровне 1,02 В и снижении частоты на один шаг в 133 МГц до 3,2 ГГц не более двух проверок QED выявили ошибку(и) во время каждого из 10 двухчасовых тестовых прогонов (с использованием теста Linpack, описанного ниже). Более того, при напряжении 1,02 В и двух шагах (т.е. 266 МГц) ниже 3,2 ГГц ошибок не было обнаружено за все время 10 двухчасовых тестовых прогонов.
В качестве проверочного теста в данном эксперименте использовался бенчмарк Linpack, который является широко распространенным бенчмарком для высокопроизводительных вычислений [Dongarra 03]. Тест Linpack, используемый в нашем эксперименте, выполняет главный цикл в течение двух часов, и в каждой итерации главного цикла выполняются одни и те же операции. Мы преобразовали исходную программу Linpack в QED-тест, проинструктировав EDDI-V на уровне исходного кода. Для каждого арифметического или логического оператора мы дублировали оператор, сохраняли результат в другой переменной и сравнивали этот результат с исходным (рис. 10).
1. Сначала мы выбрали ¢ и инжектировали окно уязвимости через ¢ циклов после каждой итерации главного цикла. Значение ¢ произвольно выбрано равным ¢p.
2. Когда тест Linpack завершал выполнение через два часа, мы просматривали лог-файл теста, чтобы определить, обнаружила ли проверка QED ошибку в какой-либо итерации главного цикла. Обратите внимание, что, хотя мы инжектировали окна уязвимостей одинаковым образом для всех итераций главного цикла, ошибки не обязательно наблюдались во всех итерациях.
3. Если ошибка не была обнаружена, мы выбирали другое произвольное начальное значение ¢ и повторяли шаг 1. В противном случае мы выполняли итерационную процедуру, чтобы переместить начало окна уязвимости ближе к моменту, когда ошибка была обнаружена впервые:
3a. Мы увеличивали ¢ на A (A - это порядка тысячи циклов) и снова запускали тест Linpack на два часа. Окна уязвимостей вводились для каждой итерации главного цикла через ¢ циклов после начала итераций главного цикла.
3b. Мы изучили файлы журнала теста, чтобы определить, продолжала ли одна и та же проверка QED первой обнаруживать ошибку.
3c. Если ошибки по-прежнему первыми обнаруживала одна и та же проверка QED, мы повторяли шаг 3a. В противном случае мы уменьшали ¢ на A и получали задержку от впрыска до обнаружения ошибки, вычитая ¢ из t, отсчета цикла от начала итерации основного цикла до момента, когда ошибка была обнаружена первой. 7 - абсолютная разница между количеством циклов в момент первого обнаружения ошибки и количеством циклов в начале соответствующей итерации основного цикла; оба количества циклов были получены путем считывания счетчика временных меток процессора и записаны в файл журнала тестирования.


[В течение двух часов, до того как тест QED обнаружит и зафиксирует ошибку, система может дать сбой. В таких случаях мы перезапускали тест до тех пор, пока суммарное время выполнения теста не достигало двух часов. Мы не можем сообщить о случаях, когда инъекция окна уязвимости приводила к сбою - ограничения нашей экспериментальной установки не позволяют нам точно зафиксировать задержки от инъекции до обнаружения в этих случаях].


Рис. 11b иллюстрирует итерационную процедуру (шаги 3a - 3c, описанные выше). Для определенного начального значения ¢ = 7, если какая-либо ошибка была обнаружена проверкой QED, мы итеративно перемещаем начало окна уязвимости ближе к моменту обнаружения ошибки, при этом проверка QED, которая первой обнаружила ошибку, остается неизменной. Это позволяет нам получить точную оценку времени от инъекции до обнаружения, то есть жесткую верхнюю границу для времени обнаружения ошибок, поскольку мы гарантируем, что проявление ошибок произошло между моментом инъекции окна уязвимости и моментом, когда проверка QED впервые обнаружила какую-либо ошибку.


3.12 Результаты задержки обнаружения ошибок


Следуя процедуре систематического эксперимента, описанной в разделе 3.1.1, мы получили 75 значений задержки от инъекции до обнаружения. Распределение для этих 75 точек данных показано на рис. 12. На рис. 12a показаны результаты теста QED Linpack на основе EDDI-V, когда мы учитываем проверки QED. Результаты "не QED" Linpack-теста, показанные на рис. 12b, были получены при игнорировании QED-проверки и учете только конечных результатов-проверки программы. Это позволяет нам сравнить задержки между инъекцией и обнаружением, полученные при использовании только проверок конечных результатов, и задержки между инъекцией и обнаружением, полученные при использовании проверок QED, в отношении одной и той же ошибки (ошибок).
Как показано на рис. 12a, при использовании QED задержки от инжекции до обнаружения очень малы - от менее чем 1 000 циклов до ~ 6 000 циклов. (Фактические задержки обнаружения ошибок еще короче, поскольку задержка от инжекции до обнаружения является лишь верхней границей). С другой стороны, без проверок QED (рис. 12b) 72 % из тех же 75 точек данных не привели к ошибкам в конечном выводе программы (по сравнению с предварительно сгенерированными золотыми результатами), что указывает на маскировку ошибок. Отметим, что мы не наблюдали ни одного случая, когда проверка конечного результата обнаружила бы ошибку, а проверка QED - нет. В оставшихся 28 % случаев, несмотря на то, что неправильные результаты программы были обнаружены конечными проверками, задержки от инъекции до обнаружения составляли порядка миллиардов циклов (даже после того, как мы вычли накладные расходы на задержки, вносимые инструментарием QED, включая как дублирование, так и проверку утверждений).


Из этих результатов можно сделать два ключевых наблюдения:
Наблюдение (1): QED значительно сокращает время обнаружения ошибок на шесть порядков по сравнению с оригинальным проверочным тестом (без QED). С помощью QED задержки обнаружения ошибок сокращаются с миллиардов циклов до нескольких тысяч циклов или меньше. Такие короткие задержки позволяют эффективно использовать многие существующие методы отладки (например, буферы трассировки на кристалле и IFRA) не только для одноядерных процессоров, но и для многоядерных SoC.
Наблюдение (2): QED обнаруживает ошибки, которые в противном случае не были бы обнаружены оригинальной программой тестирования из-за эффекта маскировки. Помимо сокращения времени задержки обнаружения ошибок, QED значительно улучшает способность тестовой программы обнаруживать ошибки.

3.13 Анализ покрытия электрических ошибок
Мы оценили влияние QED на Fmax, который часто используется для обнаружения электрических ошибок [Josephson 06], построив графики Shmoo в широком диапазоне рабочих точек напряжения и частоты. Мы использовали две версии программы Linpack: оригинальную версию без QED и версию с QED на основе EDDI-V (EDDI-V инструментировалась так же, как описано в п. 3.1.1). Версия без QED содержит проверки конечных результатов, которые сравнивают конечные результаты программы с золотыми ожидаемыми результатами. Обратите внимание, что охват не-QED теста с проверкой конечных результатов оптимистичен: ожидаемые значения, необходимые для проверки конечных результатов, могут быть доступны не для всех тестовых программ (например, операционных систем или игр). Без проверок конечных результатов тихие ошибки могут ухудшить покрытие не QED-тестов. Поскольку все QED-тесты являются корректными стимулами (т. е. не вводят в систему запрещенных состояний), значения Fmax, полученные с помощью QED-тестов, не являются пессимистичными.
На рисунке 13 подробно описана процедура эксперимента shmoo. Как QED-, так и не QED-версии теста проводились не менее 10 раз для каждой рабочей точки напряжения и частоты. Напряжения и частоты были заданы в BIOS, а температура корпуса была зафиксирована на уровне 30 °C. При каждом запуске теста система перезагружалась, и программа выполнялась в течение часа или до отказа системы. Результаты работы программы, включая любые ошибки, обнаруженные проверкой QED или проверкой конечных результатов, записывались в файл для последующего анализа.


3.14 Результаты покрытия электрических ошибок
Графики Шму для оригинального Linpack (с проверкой конечных результатов) и теста QED Linpack на основе EDDI-V представлены на рис. 14. Каждая рабочая точка частоты и напряжения классифицируется как:
1. Не загрузилась - машина не смогла загрузиться и выполнить тест. 
2. Обнаружена ошибка - во время хотя бы одного из прогонов была обнаружена ошибка в результате проверки (проверки конечного результата или проверки QED), либо произошел сбой системы.
3. Пройдено - ошибок не обнаружено. 
Сравнивая два графика шму, мы делаем три наблюдения в дополнение к двум, представленным в разделе 3.1.3:
Наблюдение (3): QED не ухудшает покрытие, определяемое по Fmax. Как показано на рис. 14, QED не увеличивает Fmax - ни в одной рабочей точке тест QED не проходил, когда тест без QED не проходил. Это эмпирически подтверждает тот факт, что тест QED продолжает создавать и обнаруживать ошибки в тех случаях, когда оригинальный тест создает и обнаруживает ошибки. Такое же поведение мы наблюдали и в стресс-тесте MPrime, выполняющем тест на первичность Лукаса-Лехмера [Mersenne 10] (результаты не показаны из-за недостатка места). 
Наблюдение (4): QED может улучшить покрытие при значительном увеличении времени задержки обнаружения ошибок. Это демонстрирует рабочая точка напряжения и частоты на рис. 14, которая прошла проверку с конечным результатом, но привела к обнаружению ошибок с помощью QED (отмечена символом @ на рис. 14a).
Тесты QED также быстрее обнаруживают ошибки по сравнению с тестами без QED. На рис. 14 мы аннотировали каждую операционную точку, классифицированную как "обнаруженная ошибка", долей запусков, в которых была обнаружена ошибка или произошел сбой. Например, на рис. 14а одна рабочая точка была помечена значением 0,9, поскольку проверки QED обнаружили ошибки в 5 прогонах, система вышла из строя в 4 прогонах, а тест прошел в 1 прогоне. Та же рабочая точка на рис. 14b была отмечена значением 0,4, потому что проверки конечных результатов обнаружили ошибки в 3 проходах, система разбилась в 1 проходе, а тест прошел в 6 проходах. Только для одной рабочей точки тест QED обнаружил ошибки в 1 из 10 прогонов, в то время как версия без QED обнаружила ошибки в 2 из 10 прогонов. Для всех остальных рабочих точек тест QED имел большее или такое же количество "обнаруженных ошибок", как и версия без QED.
Наблюдение (5): Для уменьшения задержек обнаружения ошибок и достижения высокого покрытия одних только грубых утверждений может быть недостаточно. Изучив журналы тестирования, в которых фиксировалось время обнаружения каждой ошибки, мы вычислили среднюю разницу между временем, которое потребовалось end-result-чекам для обнаружения ошибок с момента начала выполнения теста, и временем, которое потребовалось QED-чекам для обнаружения ошибок. Мы заметили, что end-result-checks, которые можно рассматривать как тип грубого утверждения, потребовалось на несколько миллиардов циклов больше времени для обнаружения ошибок, чем QED.


3.2 Результаты моделирования Мы смоделировали 4-ядерный 4-полосный внепорядковый процессор MIPS, используя как микроархитектурный симулятор SESC [Renau 05], так и RTL-модель процессора из [Wang 05], которую мы модифицировали для поддержки архитектуры набора инструкций MIPS. Мы провели моделирование для достижения двух целей: 
1. Оценить значения задержки обнаружения ошибок для тестовой программы QED Linpack на базе EDDI-V, чтобы подтвердить результаты аппаратных экспериментов в разделе 3.1.2.
2. Охарактеризовать значения задержки обнаружения ошибок для методики QED на основе H-RMT-V из раздела 2.2. Поскольку H-RMT-V требует аппаратных модификаций, он не может быть оценен на нашей существующей аппаратной платформе.

Тестовая программа Linpack, а также два приложения (FMM и Radix) из многопоточного эталонного набора Splash2 [Woo 95] были использованы для создания четырех различных тестов: Linpack с QED на базе EDDI-V (описан в разделе 3.1); Linpack, FMM и Radix с QED на базе H-RMT-V. Микроархитектурный симулятор был модифицирован для поддержки механизма H-RMT-V: были добавлены аппаратные FIFO с привязкой к памяти, и каждое ядро было модифицировано для автоматического занесения проверяемых значений в FIFO. В данной реализации H-RMT-V только операнды инструкций store и branch регистрируются и отправляются в поток проверки. Реализация может быть расширена для поддержки проверки других типов инструкций, таких как арифметические и логические операции. Результаты моделирования показывают, что наша текущая реализация H-RMT-V обеспечивает достаточно короткие задержки обнаружения ошибок (рис. 15). Все потоки H-RMT-V выполнялись на разных ядрах.
Мы использовали RTL-симулятор для определения времени, которое требуется ошибке, чтобы повлиять на состояние архитектуры (регистры общего назначения или основная память). Мы инжектировали однобитную ошибку в один случайно выбранный флип-флоп RTL-модели процессора (из 18 142 флип-флопов). Для 10 000 таких случайных инъекций ошибок ошибки не были замаскированы в 36 случаях (т. е. инъекции ошибок в конечном итоге привели к тому, что состояние архитектуры отличалось от состояния, полученного при безошибочном выполнении); в среднем прошло 70 циклов и максимум ~ 300 циклов, прежде чем инъекции ошибок распространились на состояние архитектуры. (Заметим, что мы не учитываем один случай, когда инжектированная ошибка привела к тупику до того, как было затронуто архитектурное состояние). Эти задержки согласуются с данными, представленными в [Wang 05]: почти все ошибки, которые в конечном итоге влияют на состояние архитектуры, влияют на состояние архитектуры в течение 500 инструкций.
В отдельном эксперименте мы определили время, необходимое для того, чтобы ошибка в архитектурном состоянии достигла проверки QED. Для каждого из четырех тестов мы провели 15 000 экспериментов с использованием микроархитектурного симулятора. Для каждого эксперимента мы выбирали случайную инструкцию, отмечали результат выполнения инструкции и распространяли флаг через зависимости данных до тех пор, пока не достигалась проверка QED. Отметим, что в этих экспериментах мы не смогли рассмотреть все случаи маскировки ошибок и их влияние на пути выполнения. Однако в QED короткие задержки обнаружения ошибок уменьшают количество маскировок ошибок, которые могут произойти до проверки, а обширная проверка по всем путям выполнения означает, что независимо от того, по какому пути идет выполнение, любая ошибка быстро встретится с проверкой. Поэтому значения задержек обнаружения ошибок, полученные в ходе этих экспериментов, являются реалистичными.
На рисунке 15 показано распределение задержек обнаружения ошибок в состоянии архитектуры для достижения проверки QED. Для теста Linpack с QED на базе EDDI-V 99,4% всех не маскируемых ошибок достигли проверки QED в течение 1000 циклов. Для трех других тестов с QED на основе H- RMT-V 99,9% всех не маскируемых ошибок достигли проверки QED в течение 1000 циклов. Небольшая часть немаскируемых ошибок (0,6% для EDDI-V и 0,1% для H-RMT-V) не достигла проверки QED в течение 1 000 циклов из-за ограничений наших конкретных реализаций QED. QED на базе EDDI-V был реализован на уровне исходного кода; поэтому мы не смогли задействовать проверки QED в вызовах системных или библиотечных функций. Наша реализация H-RMT-V проверяла не все инструкции, а только операнды инструкций сохранения и ветвления.
Распределение задержек обнаружения ошибок было бы похоже на то, что представлено на рис. 15. Это объясняется тем, что дополнительное время распространения ошибки до состояния архитектуры очень мало - даже если учесть среднюю задержку в 70 циклов или даже максимальную задержку в ~300 циклов в дополнение к значениям латентности, представленным на рис. 15, распределение останется похожим. Это распределение согласуется с данными, полученными в ходе аппаратного эксперимента, рассмотренного в разделе 3.1.2.


3.3 Обобщение результатов аппаратного и имитационного моделирования
Результаты, полученные в ходе экспериментов на аппаратных платформах Intel® Core™ i7, показывают, что QED не только значительно улучшает задержки обнаружения ошибок с миллиардов циклов до нескольких тысяч циклов или меньше, но и уменьшает маскировку ошибок и позволяет тесту обнаружить больше ошибок. Результаты моделирования на многоядерном процессоре MIPS подтвердили эффективность QED в улучшении задержек обнаружения ошибок. Наши аппаратные эксперименты также демонстрируют, что преобразования QED не ухудшают, а улучшают охват тестов проверки, оцененный эмпирически путем измерения максимальных значений рабочей частоты в широком диапазоне рабочих точек напряжения: мы наблюдали, что тесты QED обнаруживали ошибки в рабочих точках, в которых тесты без QED не могли обнаружить никаких ошибок.
4 Связанные работы
Предыдущие исследования, связанные с QED, можно разделить на следующие категории:
a. Методы посткремниевой отладки: Длительные задержки обнаружения ошибок являются серьезным препятствием для эффективности методов посткремниевой отладки, особенно для многоядерных SoC. Как обсуждалось в разделе 3.1.2, значительно сократив время обнаружения ошибок, QED может обеспечить более эффективную посткремниевую отладку. Многие методы локализации ошибок могут выиграть от применения QED, включая те, которые основаны на воспроизведении сбоев [Yang O9b], моделировании [Krstic 03] и анализе записанных сигналов [Park 09, 10]. Кроме того, QED может дополнить многие другие методы, облегчающие посткремниевую отладку, такие как выбор сигналов и интервалов для записи [Liu 09, Yang 08, Yang 09a], сжатие записанных событий [Anis 07, Vishnoi 09], логический анализ или формальные методы [De Paula 08, Ko 08].
b. Генерация стимулов для посткремниевой проверки: QED применим к широкому спектру тестовых программ и может преобразовывать их в соответствующие тесты QED. Например, QED можно применять к автоматически генерируемым функциональным тестам [Benardi 08, Benso 08, Krstic 02, Parvathala 02, Shen 98].


Еще одним преимуществом применения QED является то, что преобразованный тест является "самопроверяющимся", т. е. не требует отдельного золотого ответа (например, созданного с помощью моделирования). Методы, представленные в [Raina 98] и [Wagner 08], также могут генерировать такие "самопроверяющиеся" тесты, используя обратные операции для проверки корректности выполнения теста. QED может использовать эти методы для включения разнообразия в свою проверку (что может быть желательно, как обсуждается в разделе 2). Однако сами по себе эти методы не обеспечивают механизмов, гарантирующих короткие задержки обнаружения ошибок, и могут быть не в состоянии проверить все операции (например, операции сдвига).
c.  Утверждения после кремниевой проверки: Создание и использование утверждений для проверки является нетривиальной задачей: в проекте может быть до 10 000 отдельных утверждений, многие из которых создаются вручную и должны поддерживаться в актуальном состоянии, а также проверяться [Bentley 01]. Хотя были разработаны автоматические генераторы утверждений [Emst 07, Hangal 05, Li 10], генерируемые ими утверждения могут быть применимы не для всех системных и программных входов. Кроме того, утверждения могут быть не в состоянии обнаружить все ошибки (например, утверждения не могут проверить выходы блока ALU). Реконфигурируемая логика может облегчить реализацию утверждений в аппаратуре [Abramovici 06, Boule 07, Gao 08]; однако необходимо тщательно подходить к выбору "правильного" набора утверждений для реализации в аппаратуре. Если утверждения вставлены неаккуратно, они могут не обеспечить желаемых задержек обнаружения ошибок (как показано в разделе 3.1.4 для случая утверждений с проверкой конечного результата). Используя такие техники преобразования, как EDDI-V и RMT-V, QED преодолевает трудности с утверждениями, предоставляя общие и обширные проверки, которые могут быть сгенерированы автоматически. Более того, если имеются какие-либо аппаратные утверждения, QED может извлечь из них пользу, "перегрузив" часть своих проверок на эти утверждения, тем самым внося меньше интрузивности в исходный тест проверки, достигая целевой задержки обнаружения ошибок.
d. Методы проверки для отказоустойчивых вычислений: Как обсуждалось в разделе 2, ограничения и требования для отказоустойчивых вычислений и посткремниевой валидации сильно отличаются, хотя в обоих случаях могут использоваться схожие методы проверки [Lu 82, Mahmood 88, Oh 02a]. Для отказоустойчивых вычислений основными проблемами являются влияние на производительность и восстановление после ошибок. При посткремниевой проверке мы должны убедиться, что любые инструменты, добавляемые в проверочные тесты, не оказывают негативного влияния на покрытие и достаточны для низкой задержки обнаружения ошибок. Возможно, мы сможем уменьшить навязчивость QED, включив в него проверки, специфичные для конкретного приложения (Huang 84, Saxena 94], разработанные для отказоустойчивых вычислений.

5 Выводы
Быстрое обнаружение ошибок (Quick Error Detection, QED) - это эффективная техника, позволяющая преодолеть проблемы, связанные с длительным временем обнаружения ошибок в контексте посткремниевой валидации процессоров. В этой статье мы представили результаты комплексных аппаратных экспериментов и моделирования, демонстрирующие, что QED радикально улучшает задержки обнаружения ошибок на шесть порядков, с миллиардов циклов до нескольких тысяч циклов или меньше. Такое улучшение латентности обнаружения ошибок может обеспечить значительное повышение производительности посткремниевой проверки, а также существенное снижение стоимости отладочного оборудования. Более того, наши результаты эмпирически демонстрируют, что QED улучшает охват тестов посткремниевой валидации: применяя QED к существующим тестам валидации, мы можем обнаружить ошибки, которые иначе не были бы обнаружены оригинальными тестами без QED.
Будущие направления исследований QED включают: 
1. Разработка полностью автоматизированного фреймворка для QED, включающего оптимальное сочетание широкого спектра утверждений и QED-преобразований в дополнение к методам QED, представленным в данной статье. 
2. Анализ и оптимизация эффективности QED в более широком диапазоне тестовых наборов и платформ для валидации. 
3. Обобщение QED на логические ошибки. 
4. Обобщение QED на неосновные компоненты SoC.


6 Благодарности
Данное исследование частично финансируется FCRP GSRC, SRC, NSF и корпорацией Intel. Авторы благодарят Рахиму Мохаммеда из корпорации Intel за помощь в управлении тепловым режимом оборудования и общую методологию.