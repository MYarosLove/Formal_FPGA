Эффективная предварительная верификация процессорных ядер с помощью нарушения границ символики
Быстрое обнаружение ошибок
Аннотация
Существующие методы обеспечения функциональной корректности или обнаружения аппаратных троянов в процессорных ядрах во время предварительной кремниевой верификации сталкиваются с серьезными ограничениями. Мы расширяем Symbolic Quick Error Detection, недавний метод обнаружения ошибок, основанный на проверке модели с ограничениями, символическими начальными состояниями. Используя ядра RISC-V с открытым исходным кодом, мы демонстрируем: 1. Быстрое (≤5 минут (≤2,5 часа) для упорядоченного (суперскалярного) ядра) обнаружение 100% сотен сценариев логических ошибок и аппаратных троянов из коммерческих SoC и научной литературы, а также 97,9% "экстремальных" ошибок (случайно сгенерированных ошибок, требующих ~100 000 инструкций активации, взятых из случайных тестовых программ). 2. Быстрое (~1 минута) обнаружение нескольких ранее неизвестных ошибок в конструкциях RISC-V с открытым исходным кодом.

1. Введение
Предварительная верификация требует значительных усилий в типичном потоке проектирования [Foster 15]. Данная статья посвящена предварительной верификации одиночных процессорных ядер, которые являются критическими компонентами любой системы-на-кристалле (SoC). Как правило, предварительная верификация в основном направлена на устранение ошибок логического проектирования (логических ошибок). Помимо логических ошибок, будущим методам предварительной верификации, возможно, придется бороться с аппаратными троянами (HTs) [King 08], которые представляют собой несанкционированные модификации интегральной схемы (ИС), приводящие к неправильной функциональности и/или раскрытию конфиденциальных данных [Karri 10]. Хотя первоначальные исследования HTs были сосредоточены на атаках, осуществляемых на заводе-изготовителе в процессе производства, существуют также опасения, что HTs могут быть вставлены в ядра интеллектуальной собственности (IP) третьих лиц злоумышленниками [Zhang 11]. Процессорные ядра - важный класс IP-ядер, которые используются (и переиспользуются) во многих проектах для снижения стоимости разработки и удовлетворения жестких требований к срокам выхода на рынок. Таким образом, обеспечение функциональной корректности и надежности процессорных ядер является важной проблемой.
Подобно логическим ошибкам, мы рассматриваем НТ, которые влияют на функциональность; т. е. такая НТ может вызвать ошибку, которая (в конечном итоге) может привести к ошибке в программно-видимом состоянии (программно-видимых регистрах или памяти). Это охватывает многие продемонстрированные атаки на процессорные ядра [King 08]. Символическое быстрое обнаружение ошибок (QED) [Singh 18] - это новая техника предварительной верификации, основанная на идеях QED [Hong 10, Lin 12, 14, 15a]. Она использует Bounded Model Checking (BMC) [Clarke 01] для формального анализа конструкции. Это автоматизированная и быстрая техника обнаружения и локализации ошибок. Это контрастирует с традиционными методами предварительной верификации, которые в большинстве случаев выполняются вручную и не могут масштабироваться (справочная информация приведена в приложении B).
Символьный QED анализирует дизайн символически, но требует конкретного (несимволического, т. е. с явно заданными 0 и 1) начального состояния. Начать с конкретного состояния означает, что для поиска ошибок, требующих очень длинных последовательностей активации (т. е. для активации таких ошибок требуется много инструкций), Symbolic QED должен полагаться на очень глубокие прогоны BMC (т. е. прогоны, которые разворачивают схему достаточно далеко, чтобы включить все инструкции активации). Это может быть затруднительно для практических разработок. Например, в [Singh 18] говорится, что инструмент BMC может развернуть схему только примерно на 30 тактов, что составляет 24 часа времени верификации. Следующий пример HT, взятый из [Zhang 14], показывает, что символический QED, хотя и очень эффективен для многих логических ошибок, может быть недостаточным для обнаружения HT. 
Мотивирующий пример 
Рассмотрим следующий HT, который может быть трудно (см. раздел 5 для более подробного обсуждения) обнаружить во время предварительной верификации с помощью существующих методов обнаружения HT [Salmani 13, Zhang 14]: HT изменяет опкоды нескольких следующих декодированных инструкций после того, как видит определенную последовательность из 256 инструкций. 
Такой HT может внедрить короткую последовательность инструкций, чтобы обойти защиту физической памяти и запустить привилегированную инструкцию. Это пример атаки с повышением привилегий [King 08], которая может привести к катастрофе. 
Поскольку для активации HT требуется много инструкций (и много тактов), Symbolic QED (как и другие методы на основе BMC [Rajendran 15, Reece 16]) не сможет обнаружить этот пример, если только начальное состояние быстро не перейдет в состояние, в котором активируется HT. Попытка наткнуться на такое "близкое" состояние, выбрав конкретное состояние из симуляции или начав с состояния сброса, маловероятна, поскольку HT может быть спроектирован с произвольной последовательностью активации, которая не известна априори.
Чтобы преодолеть эту серьезную проблему, мы расширяем Symbolic QED так, чтобы он теперь мог стартовать из символического (а не конкретного) начального состояния (то есть мы даем инструменту BMC возможность выбирать произвольное начальное состояние). Как объясняется в следующем параграфе, BMC из символического начального состояния может быть очень сложным.

Наш подход преодолевает связанные с этим проблемы и позволяет запускать символический QED на основе BMC из состояний, которые в противном случае потребовали бы очень глубоких прогонов BMC, не поддерживаемых текущими формальными инструментами. В результате даже логические ошибки, требующие очень длинных последовательностей активации, могут быть обнаружены путем применения очень короткой последовательности инструкций после запуска из "близкого" состояния. Конечно, мы также можем обнаружить мотивирующий пример HT в течение нескольких минут.

Существующие методы предварительной верификации на основе BMC (включая существующий Symbolic QED) сталкиваются со следующей проблемой при использовании в сочетании с символическими начальными состояниями: BMC требуется свойство для проверки, а также специфические для свойства ограничения (предположения, сделанные инструментом BMC о конструкции) на символическое начальное состояние. Эти ограничения необходимы для того, чтобы инструмент BMC не выдавал ложных контрпримеров (ложных срабатываний) для проверяемого свойства. Если инструмент BMC выберет начальное состояние, которое недостижимо из множества всех допустимых состояний сброса системы с помощью допустимой последовательности инструкций, может произойти ложное срабатывание. Например, предположим, что каждое слово в памяти защищено одним четным битом четности. Предположим, что инструмент BMC должен проверить следующее свойство: при любой последовательности операций чтения и записи в память биты четности остаются согласованными с данными. Если начальное состояние конструкции не ограничено, инструмент BMC может инициализировать память, чтобы она содержала полностью нулевое слово с '1' в качестве бита четности, считать из этой ячейки памяти и сообщить об этом ложном контрпримере (который является ложным положительным результатом). Поэтому традиционные методы предполагают, что инженер по верификации должен вручную написать ограничения, чтобы исключить такие ложные срабатывания, что может занять очень много времени для больших конструкций с множеством сложных свойств.
В данной работе эта проблема решается путем: i) определения QED-ограничений: достаточных ограничений, чтобы гарантировать отсутствие ложных срабатываний при использовании символического QED с символическими начальными состояниями в одном процессорном ядре; и ii) введения QED-регистраторов, которые наблюдают небольшое подмножество внутренних сигналов в процессоре и проверяют соблюдение QED-ограничений. Регистраторы QED используются только для предварительной верификации. Они не занимают лишнюю площадь в окончательном проекте.
Ниже приведены некоторые из ключевых экспериментальных результатов, о которых мы сообщаем:
1) Мы автоматически, корректно и быстро (в течение 1 минуты) обнаружили несколько реальных логических ошибок, которые ранее были неизвестны, в суперскалярном RISC-V-ядре с открытым исходным кодом [Ridecore1].
2) Мы автоматически, корректно и быстро (в течение 25 секунд для ядра inorder; 18 минут для суперскалярного ядра) обнаружили 100 % сотен смоделированных логических ошибок, представляющих широкий спектр "сложных" сценариев (см. приложение A), которые встречались в различных коммерческих разработках.
3) Мы автоматически, корректно и быстро (в течение 5 минут для инкорпоративного ядра; 2 часов для суперскалярного ядра) обнаружили 100 % сотен смоделированных аппаратных троянцев, представляющих широкий спектр сценариев (см. приложение A) из исследовательской литературы. В отличие от этого, Symbolic QED с конкретным начальным состоянием обнаружил только 9 % таких HT.
4) Мы автоматически, корректно и быстро (в течение 2,5 часов) обнаружили 97,9 % семейства "экстремальных" ошибок (случайно сгенерированные ошибки, основанные на предусловиях, которые требуют ~100 000 инструкций активации, взятых из случайных тестовых программ) в суперскалярном ядре. В отличие от этого, Symbolic QED с конкретным начальным состоянием обнаружил 0 % таких ошибок. Эта работа опирается на предыдущую работу по Symbolic QED с символическими начальными состояниями [Fadiheh 18]. Более подробное обсуждение представлено в Приложении B.3. 
Ниже перечислены некоторые важные особенности нашей методики 
1) Она высокоэффективна для обнаружения логических ошибок и НТ (несмотря на длинные последовательности активации) во время предварительной верификации ядер последовательного и суперскалярного типов, что подтверждается нашими результатами. 
2) Не требует от инженера по верификации вручную создавать утверждения, специфичные для конкретного дизайна, для поиска логических ошибок или HT.
3) Отсутствие ложных срабатываний, что подтверждается нашими результатами.
4) Не требуется "золотая" модель или данные симуляции тестируемой конструкции
для обнаружения логических ошибок и/или HT.
5) Его эффективность не зависит от способа проектирования HT, т. е. наш
метод является агностическим по отношению к дизайну HT.
Остальная часть статьи организована следующим образом. В разделе 2 описывается, как мы расширяем Symbolic QED с помощью символических начальных состояний. В разделе 3 представлены результаты, а в разделе 4 - сопутствующие работы. В разделе 5 приводятся выводы.
В приложении A представлена классификация ошибок и НТ. В приложении B приведена история вопроса и обзор предыдущих работ по QED, а также представлен новый модуль QED (небольшой блок, используемый только во время предварительной верификации дизайна, который позволяет инструменту BMC передавать символические инструкции QED процессорному ядру), используемый в наших экспериментах в этой статье. В приложении C [Extended 18] объясняются наши предположения о том, как работают безбаговые конструкции, а в приложении D [Extended 18] подробно описано, как QED-ограничения задаются формальному инструменту.


2. Расширение символического QED с помощью символических начальных состояний
В этом разделе мы обсудим, как символическая QED [Singh 18] расширяется с помощью символических начальных состояний (справочная информация о QED и символической QED приведена в приложении B). Как было сказано во введении, основная проблема с символическими начальными состояниями заключается в ложных срабатываниях: инструмент BMC может выбрать начальное состояние, которое недостижимо из множества всех допустимых состояний сброса, используя допустимую последовательность событий (инструкций), что может привести к ложному срабатыванию. Чтобы избежать ложных срабатываний, мы определяем набор ограничений (называемых QED-ограничениями) на символическое начальное состояние (см. раздел 2.1). Для реализации этих QED-ограничений мы вводим QED-рекордеры - дополнительные аппаратные модули (используемые только во время предварительной верификации - они не занимают площадь в окончательном проекте), которые записывают небольшое подмножество внутренних логических значений процессорного ядра и проверяют, выполняются ли QED-ограничения (см. раздел 2.2). Входы и шаги по сравнению с символическим QED без символических начальных состояний показаны на рис. 1. 
Проектирование ядра


Рис. 1. (a) Входы и шаги символического QED без символических начальных состояний и (b)
Входы и шаги символической QED с символическими начальными состояниями.


2.1. Ограничения QED
Сначала определим некоторую терминологию, которую мы используем в определениях ограничений: i) Символические инструкции в полете (SIF): символы (т.е. биты состояния), выбранные инструментом BMC как часть символического начального состояния, соответствующие значениям, хранящимся в (микроархитектурных) флип-флопах внутри конвейера, которые хранят инструкции во время нормальной работы. Во время нормальной работы эти флипы заполняются инструкцией, проходящей через ядро1; ii) Символические инструкции QED: символы, представляющие инструкции, которые формируют трассировку ошибки (которая является частью контрпримера, наряду с начальным состоянием, которое назначает BMC), сгенерированную инструментом BMC; iii) T": момент времени, когда все инструкции SIF фиксируются (т. е. записываются в архитектурное состояние). Он определяется инструментом BMC; и iv) данные операнда символического QED: символы, представляющие данные операнда2 (операнд может быть либо архитектурным регистром, либо ячейкой памяти) отправленных инструкций символического QED (отправленных до T").
Рис. 2 иллюстрирует эти определения для трехступенчатого конвейера с последовательным выполнением. Когда начинается формальный анализ, существует до трех инструкций SIF, и все они фиксируются к моменту времени T". Первая инструкция Symbolic QED (R1=R1+5) поступает в конвейер, и данные ее операнда Symbolic QED становятся доступны после прохождения через стадию Dispatch.
Теперь ограничения QED представлены следующим образом (см. приложение D в [Extended 18] для более подробного описания того, как выполняется каждое ограничение):
Ограничение C-1: В момент T" все инструкции SIF зафиксированы (т. е. ни одна инструкция SIF не может записать в архитектурное состояние после T"), а все символьные инструкции QED зафиксированы после T".
Ограничение C-2: В момент T" архитектурное состояние является QED-согласованным (определение см. в приложении B). Кроме того, ничто, кроме инструкции Symbolic QED, не может записывать в состояние архитектуры после T" (например, любой тестовый режим, такой как сканирование, который может напрямую записывать в регистры, должен быть отключен).
Ограничение C-3: Все данные операнда для каждой символьной QED-инструкции I должны обладать одним из следующих свойств: 
i) если данные операнда доступны (т. е. I уже считывал данные для этого операнда), то эти данные должны совпадать с данными соответствующего регистра/места памяти (т. е. исходного места операнда) в T".
ii)3 если данные операнда недоступны в T", то I ожидает результат более ранней инструкции Symbolic QED для этих данных операнда. Этапы конвейера


Рис. 2. Пример временной диаграммы для трехступенчатого конвейера с последовательным выполнением, удовлетворяющего всем
ограничениям QED. Инструкции SIF фиксируются на Tc, перед всеми инструкциями QED.


Ограничения QED образуют достаточное условие для обеспечения отсутствия ложных срабатываний, если учесть, что любая конструкция без ошибок удовлетворяет двум предположениям после T". Эти два предположения подробно описаны и обоснованы в приложении C в [Extended 18]. Подробности о задании формальному инструменту QED-ограничений приведены в приложении D к [Extended 18].
Важно отметить, что эти же QED-ограничения не предотвращают ложных срабатываний при проверке общих свойств с помощью BMC. Например, пусть процессорное ядро стартует в состоянии, когда счетчик программы исключений (EPC) смещен, текущий ПК находится внутри процедуры обработки исключений, а в конвейере присутствуют только инструкции NOP. Это недостижимое состояние для процессоров со строгими правилами выравнивания (например, MIPS). Имеет смысл проверить свойство выравнивания EPC, поскольку возврат по неверно выровненному адресу может привести к ошибке. Даже в момент Tc, когда последовательность NOP завершена, этот EPC все еще будет выровнен неправильно, что приведет к ложному срабатыванию.
Однако при использовании ограничений с Symbolic QED мы не получим такого ложного срабатывания. Это происходит потому, что процедура обработки исключений будет заполнена корректными тестами QED, и в любой момент, когда мы утверждаем проверку QED, она не должна быть неудачной, если только в конструкции нет ошибки. Даже если ядро вернется по неверно выровненному адресу, процессор может сбойнуть, но ни одна проверка QED не сработает.


2.2. QED-записывающие устройства
Здесь мы обсудим регистраторы QED, которые используются для записи семантической информации (об операндах T" и Symbolic QED), чтобы мы могли указать ограничения QED инструменту BMC (объяснение в приложении D [Extended 18]). Для простоты понимания в разделе 2.2 и в приложении D [Extended 18] в качестве рабочего примера мы рассматриваем ядро с однократной выборкой инструкций и 5-ступенчатым конвейером последовательного выполнения, но мы также объясняем, как эта техника была расширена на суперскалярное ядро. В разделе 3 мы приводим результаты для ядра с последовательным порядком и суперскалярного ядра, подчеркивая, что методика не ограничивается только определенным типом ядра.


2.2.1. Рекордер для TC
Поскольку T" зависит от начального состояния, выбранного инструментом BMC, его нельзя определить статически до начала формального анализа. Поэтому мы добавляем в проект регистратор, который может предоставлять эту информацию формальному инструменту динамически (Symbolically). Для неупорядоченного ядра T" можно определить, просто отслеживая прогресс первой инструкции Symbolic QED, пока она не достигнет стадии фиксации (стадии записи-возврата) конвейера. В этот момент времени мы можем быть уверены, что все инструкции SIF были зафиксированы, поскольку конвейер полностью занят инструкциями Symbolic QED.
Специфика регистратора T" для 5-ступенчатого конвейера с однократной выборкой и последовательным выполнением приведена на рис. 3. На входе - сигналы готовности для всех этапов, предшествующих этапу фиксации (например, fetch_ready имеет высокий уровень, когда этап выборки готов к приему инструкции). Выходной сигнал SIF_complete равен истине, когда первая инструкция Symbolic QED проходит все этапы конвейера и достигает этапа фиксации. Режим вывода отслеживает прогресс, достигнутый инструкцией Symbolic QED на данный момент (мы позже используем этот вывод в разделе 2.2.2). Обратите внимание, что этот T" регистратор для 5-ступенчатого конвейера может быть легко модифицирован для поддержки конвейеров с произвольным числом ступеней.
Для суперскалярного ядра T"-рекордер еще более прост и использует буфер переупорядочивания (ROB). Основная идея заключается в том, чтобы пометить запись, выделенную в ROB для первой инструкции Symbolic QED. После этого SIF_complete становится истинным, когда головной указатель ROB достигает отмеченной инструкции.


2.2.2. Регистратор для операндов символического QED


Как и T", мы не можем статически определить операнды символического QED, поскольку
они зависят от начального состояния. В инструкции Symbolic QED операнд
операнд может быть либо регистром, либо ячейкой памяти. Регистратор операндов символического QED
хранит информацию для обоих случаев. Особенности
Регистратор операндов Symbolic QED для 5-этапного конвейера с однократной выборкой в порядке следования
приведена на рис. 4.


Входными данными являются: 
1) *_valid, который имеет высокий уровень, когда линии адреса и данных являются валидными;
2) *_addr, который указывает адрес регистра/памяти операнда; 
3) *_data, которая выдает данные операнда; 
4) mode, который выдает состояние T" рекордера, как показано на рис. 3. Выход *_буфер просто предоставляет все операнды Symbolic QED и их соответствующие значения. Изначально все буферы пусты. Поскольку нас интересуют только операнды Symbolic QED, мы храним в буферах информацию только об этих операндах, т. е. не храним информацию об операндах какой-либо инструкции SIF. Это обеспечивается за счет зависимости добавления новых записей в буферы от состояния регистратора T", то есть от режима (например, мы не добавляем новые записи в src1_buffer, пока все инструкции SIF не пройдут через стадию диспетчеризации). Обратите внимание, что на рис. 4 мы предполагаем, что инструкции могут считывать не более двух значений регистра и одной ячейки памяти за цикл, но идея может быть легко расширена до произвольного числа считываний.

Для суперскалярного ядра идея, представленная на рис. 5, должна быть расширена, чтобы включить операнды Symbolic QED, которые ожидают результатов предыдущих инструкций Symbolic QED. Это делается путем пометки каждого операнда как ожидающего или нет в буферах. Для ожидающего операнда мы также храним тег инструкции (номер записи ROB) инструкции, которую он ожидает. Эта информация об ожидании необходима для определения ограничения C-3 для суперскалярного ядра. Более подробная информация приведена в приложении D к [Extended 18].


3. Результаты
Мы демонстрируем эффективность Symbolic QED с символическими начальными состояниями на двух процессорных ядрах RISC-V с открытым исходным кодом. Два процессорных ядра: i) V-scale [Vscale], ядро с внутренним порядком, предназначенное для встраиваемых приложений; и ii) RIDECORE [Ridecore1], суперскалярное ядро (2-ходовой конвейер, 64 максимальные инструкции в полете, 2 ALU, 1 умножитель, 1 блок загрузки/хранения), предназначенное для высокопроизводительных приложений. Для BMC мы использовали инструмент Questa Formal (версия 10.5c) от Mentor Graphics на AMD Opteron 6438 с 128 ГБ оперативной памяти. Для каждого ядра мы установили модуль QED (приведен в Приложении B.4) вместе с соответствующими регистраторами QED в проекте и задали ограничения QED, как обсуждалось в разделах 2.1 и 2.2. Мы моделировали "длинные" логические ошибки, которые являются более сложными (т.е. требующими очень длинных последовательностей активации) версиями "сложных" сценариев логических ошибок, которые встречались в различных коммерческих SoC [Singh 18]. Эти сценарии приведены в приложении A.
Каждая ошибка моделируется как состоящая из двух частей: i) критерии активации ошибки (таблица A.1.a), то есть условия, которые должны быть выполнены для активации ошибки; ii) эффект ошибки после ее активации (таблица A.1.b). Сценарий ошибки формируется путем сопряжения одного критерия активации ошибки (таблица A.1.a) с одним эффектом ошибки (таблица A.1.b). Для наших экспериментов мы рассматривали целый ряд значений параметров из таблицы A.1, а именно: N=Y={2,4,6,16,32,64,128,256}, R=X={2,4,6,...,30}. В результате мы получили 117 логических ошибок в Vscale (критерий активации A.1.a.5 невозможен для Vscale) и 120 логических ошибок в RIDECORE. В таблице 1 мы приводим наши результаты.
Таблица 1. Результаты для инжектированных "длинных" логических ошибок и HTs. Для трасс ошибок мы указываем [минимальную, среднюю, максимальную] длину в инструкциях и тактовых циклах. Мы также сообщаем [минимальное, среднее, максимальное] время выполнения BMC (время, затрачиваемое инструментом BMC на поиск контрпримера).

Наблюдение 1: Символический QED с символическими начальными состояниями правильно и автоматически нашел все "длинные" логические ошибки менее чем за 30 минут, без необходимости писать утверждения, специфичные для дизайна, или отлаживать ложные срабатывания. Он находил сценарии ошибок с длинными последовательностями активации, где традиционные методы BMC терпят неудачу из-за малых границ доказательства BMC.
Мы также смоделировали различные сценарии аппаратных троянцев, встречающиеся в литературе. Эти сценарии приведены в таблице A.2. В таблице A.2.a приведены сценарии активации HT, которые выбраны таким образом, чтобы отразить все различные механизмы запуска HT, приведенные в бенчмарках Trust-Hub [Salmani 13], а в таблице A.2.b приведены различные эффекты, которые HT может оказывать на выполняемые инструкции при активации. Кроме того, в таблице A.2.c представлены три техники реализации HT, которые обычно используются для внедрения HT в проекты [Rajendran 15]. Эти методы используются для разработки скрытных HT, чтобы обойти обычные методы обнаружения (например, HT, разработанные по методологии из [Zhang 13a], известны тем, что обходят методы обнаружения, основанные на UCI [Hicks 10] и метриках покрытия [Hicks 10, Zhang 11]). Сценарий HT формируется при использовании одного критерия активации (табл. A.2.a) с 3 одним эффектом ошибки (табл. A.2.b), а также при соблюдении соответствующей стратегии проектирования (табл. A.2.c). Мы использовали диапазон значений параметров сценариев HT, приведенных в таблице A.2: N = {2, 4, 8, 16, 32, 64, 128, 256}, M1 = 32, 𝑋1 = 𝑋3 = {128, 256}, M3 = 64, в результате чего получилось 156 сценариев HT в Vscale (эффект ошибки A.2.b.5 невозможен в Vscale) и 195 сценариев HT в RIDECORE. Значения параметров выбраны таким образом, чтобы активация HT происходила крайне редко, и они аналогичны или выше (т. е. их сложнее активировать), чем значения, использованные в эталонных троянцах из [Salmani 13].
Наблюдение 2: Symbolic QED с символическими начальными состояниями правильно и автоматически обнаружил все HT менее чем за 2,5 часа, без необходимости писать утверждения, специфичные для дизайна, или отлаживать ложные срабатывания. Он нашел сценарии HT, в которых современные методы обнаружения HT [Hicks 10, Waksman 13, Zhang 11, Zhang 13b] неэффективны.

В дополнение к успешному поиску всех вышеперечисленных ошибок и HT, для RIDECORE символический QED с символическими начальными состояниями обнаружил три ранее неизвестных логических ошибки в конструкции. Первая ошибка была найдена менее чем за 30 минут, и она была локализована на конкретной записи станции резервирования. После исправления этой ошибки и повторного запуска Symbolic QED с символическими начальными состояниями мы обнаружили вторую ошибку в конструкции, а затем и третью, после исправления ранее найденной ошибки. Обе ошибки также были локализованы на одной и той же записи станции резервирования в станции резервирования (RS-m) блока умножения внутри ядра. Все три обнаруженные ошибки были подтверждены разработчиками RIDECORE [Ridecore2]. Подробности приведены в таблице 2.
Важно отметить, что эти три ошибки не были обнаружены путем запуска Symbolic QED, как в [Singh 18]. Эти ошибки были обнаружены благодаря новому модулю QED, представленному в данной работе (см. приложение B.4). Для обнаружения этих ошибок необходимо, чтобы две инструкции умножения (одна оригинальная и одна дублирующая) выполнялись в последовательных тактовых циклах. Модуль QED из [Singh 18] не является достаточным из-за периода ожидания, необходимого (для достижения состояния промывки конвейера) между оригинальной и дублирующей инструкциями. Короче говоря, наша новая модель QED улучшает модуль QED из [Singh 18] (более подробная информация приведена в приложении B.4), устраняя промывку конвейера и позволяя произвольно чередовать подпоследовательности оригинальных и дублирующих инструкций. Все три ошибки могут быть обнаружены с помощью Symbolic QED, запускаемого из состояния сброса при включении питания, если используется новый модуль QED (т. е. они не обязательно требуют символического начального состояния). Кроме того, время выполнения значительно улучшилось. 
Таблица 2. Найденные ошибки в RIDECORE. Мы сообщаем подробности активации и влияния ошибок, а также время работы BMC в минутах (с символическим состоянием запуска) и секундах (с конкретным состоянием запуска при включении питания). 


***
Формальный инструмент волен выбирать любые значения для символов (битов состояния), связанных с бортовыми инструкциями, включая те, которые не согласуются с логикой, управляющей этими символами. Таким образом, значения, выбранные для символов в символической бортовой "инструкции", могут представлять собой действительную бортовую инструкцию, а могут и не представлять.


Операнды могут поступать как из регистров, так и из ячеек памяти. Для регистровых операндов этапом диспетчеризации является этап чтения регистра, а для операндов памяти этапом диспетчеризации является этап чтения памяти.


Это условие необходимо для внепорядковых ядер, где существует вероятность того, что операнд Symbolic QED может ожидать инструкцию SIF вместо инструкции Symbolic QED.


Например, если первой инструкции в тестовой последовательности QED выделена ROB-запись 10, а SIF-инструкция выбрана так, что ее ROB-запись равна 15. Обратите внимание, что такое необычное распределение ROB не должно происходить ни в одном из достижимых состояний процессора, но это может произойти, когда мы начинаем из состояния Symbolic, так как мы не ограничиваем дизайн, чтобы он начинался только из достижимых состояний.


MULH - это инструкция знакового умножения, выбирающая верхнюю половину результата умножения.
MULHU - инструкция беззнакового умножения, выбирающая верхнюю половину результата умножения.

***
В дополнение к ошибкам в RIDECORE, Symbolic QED подтвердил две ошибки в Vscale, которые были обнаружены при запуске Symbolic QED из состояния конкретного сброса менее чем за 40 секунд. Эти ошибки были впервые обнаружены при выполнении S2QED [Fadiheh 18] (подробности см. в Приложении B.3) и подтверждены разработчиками. Эти ошибки связаны с ошибками в реализации Vscale привилегированной ISA RISC-V [RISCVP], в определенных регистрах состояния управления (CSR). Важно отметить, что в Vscale не реализованы тени для CSR. Поэтому при тестировании этих команд мы с помощью формальных средств убедились, что для каждого регистра CSR в памяти данных хранится "дублирующая" тень (иначе условие предположения-1 приложения C к [Extended 18] не будет выполнено даже в проекте без ошибок).
Первая ошибка возникает из-за того, что два бита в регистре MIP, которые вызывают прерывание каждый раз, когда они устанавливаются в высокий уровень в реализации RISC-V, могут быть перезаписаны в реализации Vscale. После исправления этой ошибки была обнаружена вторая, которая возникает, когда два младших бита регистра MSTATUS (которые определяют уровень привилегий проекта) устанавливаются в недопустимые значения. Подробности приведены в таблице 3.


Таблица 3. Подтвержденные ошибки в VSCALE. Мы сообщаем подробности об активации и эффекте ошибок, а также время выполнения BMC в секундах. Время выполнения указано для символического QED с конкретным начальным состоянием при включении питания.


Значение '1' записывается в определенные биты
в определенные позиции битов в КСО машинного прерывания
MIP.
Далее мы проверили устойчивость нашей методики на семействе "экстремальных" ошибок, которые срабатывают только при достижении проектом определенного набора состояний. Мы реализовали фреймворк для инъекции ошибок, который автоматически генерирует эти "экстремальные" ошибки, выполняя следующие шаги: i) Сначала запускается заданная тестовая программа на симулируемой конструкции и останавливается в случайный момент времени; ii) Запускается равномерная случайная последовательность из 100 инструкций R-типа, I-типа и Load/Store; iii) Выбирается равномерно случайное подмножество флип-флопов из множества всех флип-флопов в конструкции и сбрасываются их логические значения в файл; iv) генерирует ошибку (с заранее заданным эффектом), которую можно внедрить в дизайн, и которая активируется только тогда, когда дизайн достигает состояния, в котором все выбранные на шаге iii) флип-флопы имеют значения, заданные состоянием, сброшенным на шаге iii). Поскольку выборка флипов может представлять собой состояние симуляции, которое может быть достигнуто только при выполнении многих инструкций в симуляции, ожидается, что генерируемые ошибки будут иметь очень длинные последовательности активации. 
Мы реализовали описанный выше фреймворк на базе симуляционной установки RIDECORE и использовали тестовую программу, поставляемую вместе с разработкой, которая выполняет матричное умножение и требует более миллиона тактовых циклов для завершения (это обычная тестовая программа, а не QED-тест). Используя фреймворк, мы внедрили в RIDECORE логические ошибки с различными критериями активации, которые привели к эффекту, указанному в таблице A.1.b.3. Результаты представлены в таблице 4. Для генерации этих ошибок мы случайным образом выбрали 180 временных точек симуляции, а количество тактов, прошедших с момента запуска программы до каждой из этих временных точек симуляции, варьировалось от 26026 до 988159. Для каждой временной точки симуляции мы генерировали 10 ошибок путем случайного выбора 128 флип-флопов из дампа симуляции 10 раз, таким образом, в общей сложности получилось 1800 ошибок.
Нам удалось найти 1763 из 1800 ошибок, которые были внедрены в дизайн, в то время как Symbolic QED, начиная с состояния сброса, согласованного с QED, не смог обнаружить даже одну из этих 1800 ошибок в течение 24 часов. В остальных случаях инструмент BMC завершал работу через 24 часа, так и не сгенерировав трассировку ошибок. В таблице 4 мы не считаем эти ошибки обнаруженными.
Важно отметить, что символический QED с конкретным начальным состоянием, как в [Singh 18], не смог обнаружить ни одной из этих ошибок, независимо от того, использовался ли модуль QED из [Singh 18] или новый модуль QED из Приложения B.4, использовалось ли состояние сброса при включении питания в качестве начального состояния или конкретное QED-совместимое начальное состояние, взятое из случайного QED-теста.
Таблица 4. Результаты для "экстремальных" логических ошибок. Для трасс ошибок мы указываем [минимальную, среднюю, максимальную] длину в инструкциях и тактовых циклах. Мы также указываем [минимальное, среднее, максимальное] время выполнения BMC.


Наблюдение 4: Символический QED с символическими начальными состояниями правильно и автоматически нашел большинство логических ошибок, основанных на предусловиях состояния моделирования, и сгенерировал трассировку ошибок менее чем за 3 часа.
Наконец, в таблице 5 мы сравнили покрытие ошибок/HT, достигнутое с помощью Symbolic QED с символическим начальным состоянием и Symbolic QED с конкретным начальным состоянием. Для всех сценариев с ошибками и ТЗ для RIDECORE мы представляем эффективность символьного QED, запускаемого из состояния сброса при включении питания.
Таблица 5. Сравнение между символическим QED и символическим QED с символическим начальным состоянием с точки зрения покрытия ошибок для RIDECORE.


Наблюдение 5: Символический QED с символическим начальным состоянием достигает
значительного улучшения в покрытии ошибок по сравнению с использованием символического
QED с конкретным начальным состоянием.

4. Похожие работы
Существующие методы предварительной верификации в основном используют одну или несколько из следующих методик: i) программное моделирование; ii) эмуляция/аппаратное ускорение; iii) формальная верификация. Методы, основанные на программном моделировании, как правило, чрезвычайно медленны и требуют значительных ручных усилий для написания "хороших" тест-бенчей. Некоторые усилия можно сократить, используя направленную генерацию тестов и моделирование с ограничением случайности [Adir 04, Bergeron 03, Fine 03, 06, Gutkovich 06, Ioannides 10, Katz 12, Kitchen 07, Mishra 02, Shyam 06, Yuan 99], но эффективность этих методов для поиска ошибок в угловых случаях сомнительна [Adir 11, Mitra 10]. Аппаратное ускорение [Boule 05, Chatterjee 12, 13, Kim 04a, 04b, Mammo 12, Mavroidis 07] может быть использовано для сокращения времени симуляции, но все равно требует ручного создания "хороших" тест-бенчей для поиска ошибок и значительных усилий для переноса дизайна в среду эмуляции и проверки [Chatterjee 13]. Возможности инструментов, использующих символьный логический анализ для верификации, значительно улучшились со времен основополагающих работ [Burch 92, 94, Clarke 86] и используются для верификации абстрактных моделей процессоров [Lahiri 01, 03] и RTL [Bormann 07, Nguyen 08, Reid 16], используя набор спецификаций, предоставляемых формальному инструменту в виде утверждений [Foster 03]. Однако выбор "правильного" набора утверждений для обеспечения эффективности этих методов остается серьезной проблемой. Этот вопрос является серьезной проблемой для автоматической генерации утверждений [El Mandouh 12, Li 10, Vasudevan 10], которая может привести к взрывному росту числа утверждений, многие из которых неэффективны для выявления ошибок.
Существующие методы формальной верификации, использующие BMC [Lin 15a, Reid 16, Singh 18], имеют проблемы с обнаружением ошибок, требующих длинной последовательности активации, а стоимость доказательства теорем, используемого в [Kroening 00, Srinivasan 10, Manolios 08], очень высока [Bhadra 10]. В других работах [Das 02, Gulwani 09, Pandav 05, Su 96, 98, Thalmaier 10] предпринимаются попытки узнать инварианты конструкции, чтобы использовать их в качестве ограничений, но эти методы, как правило, являются специальными и не могут быть полностью автоматизированы.
Существующие методы обнаружения HT, которые могут быть применены в условиях предварительной верификации для выявления HT, нарушающих функциональность конструкции, в целом делятся на две категории: i) методы анализа HDL; 
ii) формальные методы [Xiao 16]. Анализ HDL может проводиться на поведенческом (например, [Zhang 11]) или структурном HDL-коде (например, [Caklr 15, Hicks 10]). Идея заключается в том, что сигналы, связанные с троянами, в основном "неиспользуемые" или "редкие" по сравнению с сигналами, которые являются частью реального дизайна. Различные методы используют разные метрики для выделения "редких" сигналов из множества всех сигналов. Некоторые методы [Cakır 15, Hicks 10, Zhang 11, Zhang 13b] используют данные моделирования вместе с метриками "редкости" (например, покрытие кода, корреляция сигналов). Эти методы требуют, чтобы данные моделирования были "хорошими" (т. е. данных должно быть достаточно, чтобы только несколько сигналов были отмечены как "редкие", и в то же время данных не должно быть "слишком много", чтобы HT были пропущены), что трудно обеспечить. Такие методы, как [Waksman 13, Yao 15], не нуждаются в данных моделирования, но также сталкиваются с проблемой обмена ложноположительных (т.е. ложного обнаружения HT) на ложноотрицательные (т.е. необнаружение HT) и наоборот, в зависимости от пороговых значений, установленных для их метрик "редкости". Кроме того, были разработаны скрытые HT [Zhang 14] для обхода методов анализа HDL [Hicks 10, Waksman 13, Zhang 11, Zhang 13b]. 
В отличие от этого, наша методика: 
i) не нуждается в данных моделирования; 
ii) обнаруживает HT, приведенные в [Salmani 13, Zhang 13a, Zhang 14]; iii) не сталкивается с проблемой ложных срабатываний. 
Формальные методы для поиска HT обычно используют либо BMC [Rajendran 15, 16], либо проверку эквивалентности на основе SAT [Banga 10, Reece 16, Shrestha 12], либо доказательство теорем [Guo 17, Jin 13, Love 12]. Все эти методы требуют ручной разработки свойств (и доказательств, если используется доказательство теорем) и сталкиваются с теми же ограничениями, что и традиционные формальные методы, используемые в предварительной верификации, как уже говорилось ранее. В частности, в [Banga 10, Rajendran 15, Reece 16, Shrestha 12] не удается найти HT, требующие длинной последовательности активации (например, HT, который срабатывает только тогда, когда 128-битный счетчик достигает своего наибольшего значения), в то время как наша методика их находит. Кроме того, методы проверки эквивалентности на основе SAT, такие как [Banga 10, Reece 16, Shrestha 12], требуют "золотой" модели конструкции для сравнения, которая нам не нужна. К работам, дополняющим данную работу, относятся методы, направленные на обнаружение HT, в которых происходит утечка конфиденциальных данных [Fern 17, Hu 16, Jin 12, Rajendran 16], и методы предотвращения HT [Chakraborty 09, Dupuis 14, Samimi 16, Waksman 11].

5. Заключение
В этой статье мы расширили Symbolic QED с помощью символических начальных состояний, чтобы преодолеть ограничения существующих методов предварительной верификации для обнаружения логических ошибок и HT. Мы автоматически, эффективно и быстро находили "трудные" логические ошибки и НТ, что было продемонстрировано на процессорных ядрах RISC-V с открытым исходным кодом. Будущие направления исследований включают: 
i) обнаружение логических ошибок и HT в других компонентах SoC, например,
ii) обработка других QED-преобразований, таких как CFTSS-V и CFCSS-V [Singh 18]; 
iii) автоматическое извлечение информации, необходимой для записи ограничений на символическое начальное состояние; 
iv) изучение методов абстракции для сокращения времени выполнения и дальнейшего увеличения границ BMC; и 
v) полное понимание компромиссов между техникой символических начальных состояний, разработанной в данной работе, и S2QED [Fadiheh 18].

B.4. Новый модуль QED для однопроцессорных ядер
Здесь мы описываем модуль QED, который мы использовали для запуска Symbolic QED на однопроцессорных ядрах. Этот новый QED-модуль отличается от QED-модуля, использованного в [Singh 18], и мы показываем (см. раздел 3), что существуют специфические ошибки, которые могут быть пойманы только этим новым QED-модулем, но не предыдущим. Псевдокод модуля QED приведен на рис. 6(a). Входами являются: 
1) enable, который отключает модуль QED, если он равен 0; 
2) next_instruction - следующая выбранная последовательная инструкция для выполнения; 3) fetch_next - высокий уровень, когда ядро готово к приему инструкции (т. е. этап выборки не остановлен); 
4) original, который указывает модулю на выполнение оригинальной инструкции (при высоком уровне) или дублирующей инструкции (при низком уровне). Выходами модуля QED являются: 1) instruction_valid, который показывает, является ли выходная инструкция действительной или нет; и 2) instruction_out, который указывает на инструкцию, которая должна быть выполнена. 


Модуль QED имеет внутренние переменные: 
1) queue - структура данных очереди, используемая для хранения ранее просмотренных оригинальных инструкций, которые еще не были выполнены в дублирующей подпоследовательности; 
2) head_instruction - предыдущая глава очереди; 
3) insert_valid - истина, когда модуль QED может выполнить оригинальную инструкцию; 
4) delete_valid - истина, когда модуль QED может выполнить дублирующую инструкцию; 
5) duplicate_instruction - следующая инструкция в дублирующей подпоследовательности, которая будет выполнена (используется только в случае, когда original равен 0).
Чтобы запустить Symbolic QED, нам также нужно определить, когда безопасно выдавать проверки QED, т. е. логику для сигнала qed_ready. Псевдокод для определения qed_ready для модуля QED на рис. 6(a) приведен на рис. 6(b). Чтобы избежать ложных срабатываний, мы проверяем QED только тогда, когда в регистры, сопоставленные с оригинальными инструкциями, и в регистры, сопоставленные с дублирующими инструкциями, было произведено равное количество фиксаций (записей). Этого можно добиться, отслеживая количество фиксаций оригинальных и дублирующих инструкций в регистровом наборе, как показано на рис. 6(b). Для простоты на рис. 6(b) мы предполагаем, что за цикл может быть зафиксирована не более одной инструкции. Для суперскалярных процессоров, которые могут фиксировать несколько инструкций в одном цикле, мы просто отслеживаем все соответствующие пары сигналов write_valid (который сообщает, являются ли входные данные для записи действительными) и write_address (который обозначает адрес для записи данных), имеем отдельный сигнал is_original (который определяет, соответствует ли адрес "оригинальному" или "дублирующему" местоположению) для каждого адреса, и позволяем счетчикам оригиналов и дубликатов увеличиваться несколько раз на основе оценки каждого из сигналов is_original 7.


В отличие от этого, модуль QED из [Singh 18] требует, чтобы все оригинальные инструкции были завершены, наступил период ожидания для промывки конвейера ядра и, наконец, были выполнены дублирующие инструкции, прежде чем будет подан сигнал qed_ready. Данный модуль QED вместо этого позволяет произвольно чередовать (просто передавая управление исходным входом рис. 6(a) инструменту BMC) последовательности оригинальных и дублирующих инструкций, не требуя периода ожидания перед проверкой QED.
Логика разрешения готовности QED на рис. 6(b) может быть усовершенствована: 1. Текущая логика разрешения готовности QED применима только к однопроцессорным ядрам, поскольку для многоядерной системы потребуется модификация логики qed_ready для учета оригинальных и дублирующих фиксаций на всех ядрах. Это может быть проблематично в ситуациях, когда несколько ядер работают с общим адресным пространством, поскольку проверки QED требуют согласованности кэша, чтобы избежать ложных срабатываний. Для простоты мы не рассматриваем эту ситуацию в данной статье.
2. Для некоторых процессоров, например суперскалярных процессоров с явным переименованием регистров (MIPS 10000 [MIPS 96] и ARM's Cortex-A15 [ARM]), определение оригинальной или дублирующей инструкции не может быть сделано только по месту записи (в отличие от рис. 6(b)). Эту проблему можно легко исправить, включив текущее состояние таблицы сопоставления регистров в качестве входного параметра функции is_write_to_original_space. Кроме того, каждый раз, когда происходит проверка QED, необходимо использовать ту же таблицу отображения для сопоставления каждого логического адреса с его текущим физическим адресом, прежде чем сравнивать "оригинальные" и "дублированные" значения. Однако ядра RISC-V, используемые в данной работе, не имеют этой проблемы.