G-QED: Generalized QED Pre-silicon Verification beyond Non-Interfering Hardware Accelerators
**G-QED: Обобщенная предварительная верификация QED для невмешивающихся аппаратных ускорителей**

Аннотация - Аппаратные ускорители (АУ) лежат в основе высокопроизводительных и энергоэффективных цифровых систем. Корректность этих систем, таким образом, зависит от корректности входящих в них НА. Методы предварительной верификации, основанные на самосогласованности, такие как A-QED (Accelerator Quick Error Detection), обеспечивают быструю и доказательно тщательную верификацию НА, которая не требует обширных свойств, специфичных для конструкции, или полной функциональной спецификации. **Однако A-QED ограничивается проверкой невмешивающихся НА - т. е. выдающих один и тот же результат для данного входа независимо от его контекста в последовательности входов.** Мы представляем новую технику, названную G-QED (Generalized QED), которая выходит за рамки не вмешивающихся НА, сохраняя при этом преимущества A-QED. Наши обширные результаты, а также подробное промышленное исследование показывают, что: **G-QED очень тщательно выявляет критические ошибки в хорошо проверенных конструкциях, которые в противном случае не удается обнаружить традиционным потокам верификации, и одновременно повышает производительность верификации в 18 раз (с 370 человеко-дней до 21 человеко-дня). Эти результаты подкреплены теоретическими гарантиями правильности и полноты.**

Индексные термины - QED, быстрое обнаружение ошибок, ускорители, процессоры, функциональная согласованность

I. ВВЕДЕНИЕ
Аппаратные ускорители (АУ), специфичные для конкретной области, становятся все более важными для высокопроизводительных и энергоэффективных цифровых систем. Современные цифровые системы, часто называемые системами-на-чипе или SoC, содержат множество НА, охватывающих различные области применения. Каждый HA реализует набор функций, которые в данной статье называются действиями. HA могут быть тесно связаны друг с другом, например, интегрированы в конвейер процессора. Однако чаще всего HA слабо связаны друг с другом, взаимодействуя с другими компонентами SoC (другими HA, процессорными ядрами, памятью) через сети на кристалле. Учитывая их повсеместное распространение [1], [2], слабосвязанные НА (LCA) являются основной темой данной статьи, хотя представленные нами методы могут быть применены и к жестко связанным НА.
Каждый НА должен быть проверен на корректность как тщательно, так и быстро, чтобы соответствовать требованиям времени выхода на рынок разнообразных приложений, которые они поддерживают [3]. Как обсуждалось во многих предыдущих публикациях [4]-[7], формальная верификация НА сталкивается с такими проблемами, как: **(1) огромные усилия, требуемые для создания очень тщательных свойств, специфичных для конструкции, и полных функциональных спецификаций, и (2) масштабируемость готовых формальных инструментов. Помимо того, что это занимает много времени и чревато ошибками [4], [5], создание тщательных свойств и спецификаций является нелегкой задачей из-за быстро развивающейся природы НА, поддерживающих быстро развивающиеся приложения.**
Недавно разработанная методика верификации, ускоренное быстрое обнаружение ошибок (A-QED, [6], [7]), позволяет преодолеть вышеуказанные трудности для класса невмешивающихся НА - т. е. НА, которые производят один и тот же вывод для данного действия независимо от его контекста в последовательности действий. **A-QED использует формальную верификацию, основанную на проверке ограниченных моделей (Bounded Model Checking, BMC, [8]). В отличие от обычной проверки на основе BMC, A-QED не требует
не требует определения свойств, специфичных для конструкции, или полной функциональной спецификации. Вместо этого A-QED использует проверку самосогласованности для данного HA. В частности, A-QED проверяет функциональную согласованность (FC) - свойство, согласно которому действия с одинаковыми входами всегда приводят к одинаковым выходам. В дополнение к FC, A-QED также выполняет проверку одного действия (SAC) и проверку границ ответа (RB), о которых мы расскажем далее в этой статье. A-QED является
надежным и полным для невмешивающихся НА.**
В то время как невмешивающиеся НА легко охватывают ряд конструкций с фиксированными функциями, вмешивающиеся НА становятся все более и более распространенными. Отчасти это связано с появлением программируемых ВА [9]. Фактически, традиционные процессоры можно рассматривать как крайний случай интерферирующих ВА, где каждая инструкция является действием ВА. Интерферирующие НА содержат интерферирующие действия, чьи выходы зависят от выходов других действий, что по своей сути нарушает проверку FC в A-QED. Чтобы еще больше усложнить ситуацию, действие НА может считывать выходы, произведенные другим действием (или записывать свои выходы для суммирования другим действием), на тактах, которые зависят от выполнения различных других одновременных действий, активных в НА. Таким образом, существует острая необходимость в новой и общей методологии формальной верификации для интерферирующих (и неинтерферирующих) НА, которая сохраняет преимущества A-QED (т.е. доказательно обоснованная и полная верификация, не требующая обширных свойств, специфичных для конструкции, или полных функциональных спецификаций), в то время как рассуждения об интерферирующих действиях (невозможные при использовании A-QED) - очень сложная задача.
В данной работе мы преодолеваем эту проблему с помощью G-QED или обобщенного QED - новой техники для тщательной проверки как вмешивающихся, так и невмешивающихся HA (и процессорных ядер в целом) - и вносим следующий вклад:
Мы представляем методику G-QED, позволяющую тщательно проверить HA, не требуя детального знания его конструкции или характера вмешательства различных действий". G-QED поддерживает как RTL, так и высокоуровневые потоки синтеза и легко интегрируется с несколькими промышленными инструментами BMC. e 
Мы предоставляем формальную модель НА, демонстрируем ее широкую применимость и доказываем гарантии состоятельности и полноты G-QED для таких НА. 
**Мы демонстрируем эффективность и практичность G-QED с помощью обширных результатов на широком спектре из 44 умеренных HA и процессорных ядер (которые подходят для существующих инструментов BMC).
Мы представляем промышленный пример на реальных образцах и демонстрируем: (1) Значительно улучшенное покрытие ошибок G-QED за счет уникального обнаружения угловых ошибок, которые избежали промышленного потока верификации (основанного на моделировании и формальной верификации) (в дополнение к обнаружению всех ошибок, выявленных промышленным потоком). (2) Значительное повышение производительности верификации G-QED: с 370 человеко-дней при использовании промышленного потока до всего 21 человеко-дня при использовании G-QED - 18-кратное увеличение. (3) G-QED позволил создавать короткие циклы верификации между дизайном и разработкой с быстрой готовностью для быстро меняющихся дизайнов.**

Хотя мы рассматриваем HA умеренного размера, которые могут быть использованы в существующих инструментах BMC, существуют и другие возможности расширения, например, новые методы декомпозиции с помощью проверки самосогласованности [7] - это тема будущей работы.


II. МОТИВИРУЮЩИЙ ПРИМЕР
Репрезентативный ВА на рис. 1 (адаптированный из коммерческого проекта) используется для иллюстрации проблем верификации интерферирующих ВА. HA подключен к другим компонентам SoC с помощью протокола рукопожатия, аналогичного [6]. HA считывает действительные входы (in_valid asserted) из сети только тогда, когда он готов (rdy_our asserted). Сеть считывает генерируемые HA выходы (out_valid asserted), когда она не заблокирована другими компонентами (rdy_in asserted). HA реализует 3 действия {A1, Az, As} следующим образом:
A1(D): обновляет регистр обхода с D.
A2(D): обновляет регистр Factor с D. Az хранится в FIFO 2.
A3(D, Bypass, Factor): генерирует выход O = F(D), масштабированный по значению регистра фактора. Операция масштабирования пропускается в зависимости от значения регистра Bypass. A3 сохраняется в FIFO 1. Выход этого интерференционного действия зависит не только от D, но и от значений регистров Factor и Bypass. Регистры Bypass и Factor представляют собой регистры соответствующих состояний (RSR) A3. Формальное определение RSR дано в 
Раздел IV
Вычисление F() и Scaler() занимает несколько циклов, и ожидающие входы хранятся в FIFO. Если любой из FIFO переполнен, HA переключается на быструю реализацию F(). Если любой из входов Scaler() равен 0, блок предназначен для пропуска вычислений для повышения энергопотребления и производительности. Таким образом, когда блок Scaler() обходится, HA обновляет регистр F'actor на 0.
Рассмотрим следующую ошибку (адаптированную из реальной ошибки) - сигнал FIFO I full становится высоким только тогда, когда указатель записи достигает 15 (начиная с 0), но FIFO может содержать не более 15 записей. Следовательно, запись 16** A3 перезаписывает свою предшественницу. Эта ошибка проявляется только в том случае, если rdy_in находится в низком уровне достаточно долго. Его можно обнаружить, проверив A3 на FC. Однако, чтобы выполнить FC, нам нужно ограничить RSR, чтобы предотвратить ложные срабатывания.


Проблема 1: Точные такты считывания RSR зависят от внутреннего состояния и могут быть разными для разных RSR. Например, рассмотрим действие A3. Когда результат F'() подается на Scaler(), значение, хранящееся в Factor, также считывается. Очень важно точно указать такт, в течение которого должно быть считано это значение. Это непростая задача, поскольку она зависит от задержки F'() (которая, в свою очередь, зависит от состояния FIFO 1). Неверная информация о времени может привести к ложным срабатываниям.

Задача 2: Рассмотрим ту же ошибку в FIFO 2. Если мы ограничим Factor фиксированным значением, As всегда будет считывать одно и то же значение из регистра Factor и пройдет проверку FC.

Задача 3: Проверка FC на A2 - нетривиальная задача, поскольку обновление может произойти либо из A2, либо потому, что HA обновляет его до 0, когда Scaler() обходится. Поэтому не обязательно, что вход 2°" приведет к обновлению i*" в регистре Factor. Таким образом, чтобы выяснить, когда вход обновляет регистр, нам нужно понять реализацию дизайна.

III. G-QED
Новый подход к FC показан на рис. 2. Чтобы проверить FC для пары действий {a,b}, BMC запускает три копии HA из состояния сброса. Одна и та же входная последовательность I0 ... Ik; подается на первые две копии. Для первой копии HA разрешается завершить выполнение всех входов, а затем сохраняются РСР для действий a и b. Для второй копии на вход НА подается пара Ia, Ib, соответствующая паре действий {a,b}, и записывается пара выходов {Oa, Ob}. Для третьей копии входная последовательность Im+1 In, которая не обязательно совпадает с I0 ... Ik, дается возможность завершить выполнение перед отправкой входной пары I0 ... Ik в HA. RSR сохраняются перед отправкой Ia, Ib и ограничиваются тем, что они совпадают со значениями RSR, сохраненными в первой копии. Кроме того, выходная пара {Oa, Ob} сверяется с выходной парой из второй копии. Свойство FC формулируется следующим образом:
Мы предполагаем, что РСР, используемые для вычисления {Oa, Ob} во второй копии, имеют те же значения, что и сохраненные в первой копии. Это проясняется в следующем ограничении на проектирование: 
Проектное ограничение: Если мы посылаем входную пару {Ia, Ib} после завершения выполнения всех входов в первой копии, то сгенерированная выходная пара будет такой же, как {Oa, Ob} во второй копии.
Это означает, что выход, генерируемый или RSR, обновляемый действием в последовательности, не зависит от того, сколько времени конструкция простаивает между входами. Пример HA в разделе II простаивает, когда in_valid имеет низкий уровень. В это время HA больше не принимает никаких входов, но предыдущие входы продолжают выполняться. Мы убедились, что это ограничение справедливо для всех конструкций, которые мы рассматривали в разделе V. Мы избегаем проблем I и 2, ограничивая RSR, когда входы не выполняются.
В случае задачи 3 значение фактора, обновленное A2, может быть передано как выход будущего действия Az. Таким образом, мы решаем задачу 3 с помощью FC для пары действий {A2, A3} вместо проверки FC для действия A2.

Попарная проверка действий позволяет нам найти ошибки в логике обновления RSR, так как проверка RSR напрямую нетривиальна для общего HA, как обсуждалось в задаче 3 в разделе IL. Однако для процессоров это не так, поэтому мы рассматриваем все RSR как выход каждой инструкции. Таким образом, для процессоров нам не нужно проверять инструкции попарно. 
Чтобы отловить ошибку FIFO 2, запускается BMC:
В первом экземпляре входная последовательность такова, что заполнено 14 записей FIFO. После завершения выполнения входной последовательности она соберет RSR.

Во второй копии - та же последовательность, за которой следуют Ia2, Ia3 и Ia2. Из-за ошибки Ia2 будет перезаписана, и на выходе получится F(Ia3) * Ia2.
В третьей копии входная последовательность такова, что значения RSR после ее завершения совпадают со значениями RSR первой копии. Далее BMC посылает Ia2, Ia3, и на выходе будет F(I4,) x Ij2, не равное выходу
во второй копии.
Аналогичным образом можно отловить ошибку в FIFO 1.
Чтобы убедиться в полноте, мы запускаем RB, а также SAC [6]. RB проверяет, что выход для входа в последовательности генерируется в течение некоторого времени. Она работает для мешающих НА. Чтобы проверить SAC для мешающих действий, нам нужно рассмотреть значения RSR. Чтобы выполнить SAC для пары действий {A1, A2}, начиная с состояния сброса, мы проверяем, что для всех допустимых входных значений и связанных с ними RSR выход, произведенный HA, совпадает с ожидаемым от действий A и Ap.

IV. ФОРМАЛЬНЫЕ МОДЕЛИ И ТЕОРЕТИЧЕСКИЕ РЕЗУЛЬТАТЫ
В этом разделе мы формализуем G-QED. Мы адаптируем формализм HA из [6] для моделирования общего набора HA. Такие системы переходов неявно включают тактовый сигнал для синхронизации переходов между состояниями системы [10]. Кроме того, мы формально определяем понятие RSRs, полную корректность HA в контексте RSRs и свойство FC. Мы доказываем, что FC является как корректным, так и полным.

Сначала мы упрощаем модель НА в [6], моделируя все избыточные входы (либо потому, что НА не готов к чтению, либо потому, что вход недействителен) как недействительное действие a (в [6] эти два случая избыточности рассматривались отдельно). Аналогично мы моделируем избыточные выходы (недействительные или хост не готов прочитать выход) как 0, . Для моделирования действий, которые только обновляют RSR и не производят никаких выходов, мы отличаем A,. от полного набора действий A. Действия, которые обновляют регистры Bypass и Factor на рис. 1, относятся к этому классу действий.

V. РЕЗУЛЬТАТЫ

A. G-QED для различных ВА и процессорных ядер
Мы демонстрируем эффективность и практичность GCQED на примере 44 проектов, охватывающих широкий спектр ВА и процессорных ядер, включая несколько промышленных образцов. Хотя мы сосредоточились на мешающих НА, мы также включили невмешивающиеся НА, чтобы продемонстрировать универсальность G-QED. НА представляют различные области применения, такие как безопасность, нейронные сети и обработка изображений. Процессорные ядра принадлежат к семейству RISC- V [11], ориентированному на встраиваемые системы безопасности и автомобильные области. Размеры конструкции подходят для существующих инструментов BMC.
В таблице I приведены результаты. Все проекты были предварительно проверены с помощью современных методов верификации на основе моделирования. Промышленные образцы были дополнительно проверены с помощью современной формальной верификации. Все проекты были доступны на языке Verilog RTL. Для выполнения G-QED на Open Source Designs мы использовали JasperGold® (V2016.09p002) на Intel®Xeon® ES- 2640 v3 с 128 ГБ оперативной памяти. Для запуска G-QED на промышленных образцах мы использовали OneSpin 360 DV-Verify® на Intel®Xeon®E5-2690 v3@2.6GHz с 50 ГБ оперативной памяти.


Наблюдение 1: G-QED обеспечивает тщательную проверку широкого спектра HA и процессорных ядер. G-QED уникальным образом обнаружил ошибки, которые были пропущены обычными верификационными потоками (включающими как моделирование, так и традиционную формальную верификацию), в дополнение ко всем ошибкам, обнаруженным с помощью этих потоков. Ошибки, уникально обнаруженные G-QED, представляют собой угловые сценарии, которые зачастую очень сложно обнаружить. Например, для проекта AIE-A G-QED обнаружил сложную ошибку, которая возникала из-за сложной последовательности из 16 действий, приводящей к тому, что некоторые входы другого действия отбрасывались. G-QED смог обнаружить эту ошибку в течение 5 часов с помощью контрпримера из 32 циклов. Из нашего промышленного опыта следует, что такие ошибки очень сложно обнаружить с помощью симуляторов.


Наблюдение 2: G-QED позволяет быстро проверить HA и процессоры. G-QED быстро обнаруживает ошибки с помощью коротких контрпримеров (в терминах тактовых циклов), что, в свою очередь, обеспечивает быструю отладку. Поскольку G-QED использует BMC, он находит кратчайшую последовательность для обнаружения ошибок. Это резко отличается от обычных потоков, где длина контрпримеров и трассировка ошибок сильно зависят от точности свойств, утверждений и тестовых примеров. Усилия, необходимые для настройки G-QED, невелики, что приводит к большим преимуществам в производительности верификации - сравнение с промышленными потоками верификации представлено в разделе V-B.


Замечание 3: G-QED обеспечивает единое решение для верификации мешающих HA, невмешивающихся HA и процессорных ядер. Таким образом, G-QED является передовым решением по сравнению с другими методами предварительной верификации QED, такими как A-QED [6] (для невмешивающихся ВА), Symbolic QED [12], S?QED [13] и C-S2QED [14] (для процессорных ядер).
Наблюдение 4: G-QED легко интегрируется с различными движками BMC. Мы использовали G-QED вместе с Jasper- Gold® (V2016.09p002) от Cadence и OneSpin 360 DV- Verify® от Siemens EDA для генерации Таблица I. B. Промышленный пример на живых образцах
Чтобы сравнить G-QED с промышленными верификационными потоками, мы провели тематическое исследование с использованием высокопроизводительных устройств Artificial Intelligence Engine (AJE). У нас был доступ к нескольким (с ошибками) версиям двух Verilog-проектов, AIE-A и AIE-D (таблица I, где AIE-D - производная AIE-A с дополнительными возможностями). Обе конструкции представляют собой мешающие НА, которые также являются LCA. В начале нашего исследования G-QED оба НА уже прошли предварительную верификацию и находились на завершающей стадии разработки - поэтому мы называем их "погружными".


1) Поток промышленной верификации: наш поток промышленной верификации включал как моделирование с ограничением случайности (CRS) с использованием тестового стенда на базе UVM [15], так и формальную верификацию (FV) с учетом свойств конкретного дизайна. CRS проводилось на верхнем уровне, охватывая всю функциональность конструкции. Для создания свойств, специфичных для конструкции, использовался фреймворк, аналогичный [16], чтобы сократить ручную работу. Использовался стандартный процесс промышленной верификации, аналогичный [17]. Критериями проверки были 100 % покрытие структурного кода и 100 % функциональное покрытие от CRS и FV вместе взятых.
2) Поток G-QED: Для каждого AIE HA мы определили набор действий и извлекли соответствующие регистры RSR и детали протокола интерфейса ввода-вывода с помощью инженеров-разработчиков. Затем мы использовали методологию, описанную в разделе III. Знание внутренней архитектуры (оптимизация производительности, параллелизм, внутренняя конвейеризация) или существующей промышленной верификации не требовалось. С помощью G-QED FC (раздел IID) мы смогли обнаружить и устранить 9 новых ошибок (пропущенных промышленным потоком) в течение 3 недель, в дополнение к ошибкам, обнаруженным промышленным потоком (табл. II).

Наблюдение 5: G-QED значительно улучшает покрытие ошибок по сравнению с промышленными потоками верификации. G-QED уникальным образом обнаружил 9 угловых и трудно активируемых ошибок в хорошо проверенных промышленных образцах. Из этих 9 ошибок 4 были связаны с неточностями спецификации, а 5 - с RTL-реализациями, которые вызывались только сложной последовательностью действий. Все эти ошибки были обнаружены менее чем за 5 часов.


Наблюдение 6: G-QED значительно повышает производительность верификации. Промышленный поток верификации требовал 370 человеко-дней для двух HA. G-QED потребовался всего 21 человеко-день (включая настройку, запуск инструмента BMC и анализ корневых причин) - это 18-кратное увеличение производительности верификации.


Наблюдение 7: G-QED можно настроить очень быстро. Для AIE-A и AIE-D на настройку G-QED потребовалось всего 7 и 2 человеко-дня соответственно. В отличие от этого, промышленные верификационные потоки часто требуют подробной информации о конструкции и ее реализации. Для AIE HA потребовалось 250 человеко-дней для создания CRS и FV (испытательный стенд и разработка свойств).


Наблюдение 8: G-QED обеспечивает быструю отладку. G-QED создал короткие контрпримеры (32 цикла или меньше) для AIE HAs (Таблица I), что позволило быстро отладить их (менее одного дня). анализ причин. Усилия G-QED в Таблице II включают эти усилия по отладке. В отличие от этого, анализ первопричины некоторых ошибок, обнаруженных CRS, занял несколько дней.


Наблюдение 9: G-QED не требует низкоуровневых деталей проектирования. G-QED в основном полагается на проверку самосогласованности, что сводит к минимуму необходимость в глубоком понимании деталей конструкции. Это значительно экономит усилия по верификации.


Наблюдение 10: G-QED позволяет выполнять короткие циклы верификации между дизайном и разработкой с быстрым временем выполнения для быстро развивающихся дизайнов. Как только ошибки, обнаруженные G-QED, были исправлены, мы могли сразу же использовать G-QED для верификации исправленных конструкций без дополнительных усилий. В отличие от этого, CRS и FV требовалось до 120 человеко-дней для отладки, исправления, обновления тестовых примеров и свойств, а также повторной верификации.


VI. СМЕЖНАЯ РАБОТА
Методологии, основанные на моделировании, доминируют в практике предварительной верификации в промышленности [15], [17], [18]. Однако, как показано в разделе V-B, методы, основанные на моделировании, недостаточны для обеспечения тщательной и быстрой верификации ВА. В то время как моделирование масштабируется для больших конструкций, для G-QED могут быть открыты широкие возможности масштабирования с помощью таких методов, как [7] - это тема будущей работы.
Хотя G-QED использует BMC для проверки самосогласованности, он отличается от традиционной формальной верификации (раздел V-B). G-QED может использовать последние достижения в области формальной верификации для дальнейшего сокращения ручного труда (например, автоматическое извлечение RSR [19], ILA [5]).
**Проверка на основе самосогласованности берет свое начало в отказоустойчивых вычислениях, включая использование разнообразия конструкций. Для предварительной верификации актуальны такие публикации, как [20], [21]. Эти методы могут повлиять на гарантии полноты (например, для ошибки, всегда вызываемой определенной последовательностью инструкций, независимо от количества NOP и остановок, вставленных в эту последовательность). Другой близкий подход [22] требует определенных тактовых циклов при чтении и записи RSR, что может быть очень сложным для НА (раздел ID). В отличие от него, мы доказали, что G-QED является надежным и полным.**


ТАБЛИЦА IL. G-QED VS. ДРУГИЕ МЕТОДЫ ДОКРЕМНИЕВОГО КВАНТОВАНИЯ


В последнее время появилось несколько публикаций, посвященных различным вариантам методов предварительной верификации QED, а именно: Symbolic QED [12], S?QED [13], C-S2QED [14], A-QED [6] и A-QED? [7]. В таблице III приведено сравнение этих методов с G-QED по различным параметрам.


VII. ЗАКЛЮЧЕНИЕ
G-QED представляет собой единый подход к тщательной предварительной верификации мешающих HA, невмешивающихся HA и процессорных ядер на основе самосогласованности. При скромных проектных предположениях G-QED доказал свою состоятельность и полноту. Результаты широкого спектра проектов, включая промышленный пример, демонстрируют его эффективность и практичность. G-QED создает несколько перспективных направлений исследований: (1) масштабирование до очень больших конструкций с помощью новых методов декомпозиции и абстрагирования (например, [7]). (2) G-QED с символическими начальными состояниями для преодоления ограничений BMC; (3) G-QED для проверки сторонних IP-блоков с малым количеством/неразборчивостью внутренних деталей конструкции; (4) проверка функциональной безопасности с помощью комбинации G-QED и формальных методов инжекции ошибок; и (5) G-QED для выведения атак на побочные каналы в HA (аналогично побочным каналам синхронизации для процессоров [24]).


БЛАГОДАРНОСТЬ 
Эта работа была частично поддержана ACE (одним из семи центров JUMP 2.0, программы Semiconductor Research Corporation (SRC), спонсируемой DARPA), Стэнфордским альянсом SystemX и спонсируемой SRC программой Global Research Collaboration.