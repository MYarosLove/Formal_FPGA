##Символьное быстрое обнаружение ошибок для предкремниевой и посткремниевой валидации: Часто задаваемые вопросы
Сокращение времени задержки обнаружения ошибок имеет решающее значение для улучшения видимости дизайна при поиске ошибок. В этой статье в формате FAQ обсуждаются ключевые моменты метода символического QED, который может применяться как при предкремниевой, так и при посткремниевой валидации.

###Вопрос 1: Каковы основные проблемы предкремниевой верификации?
Предкремниевая верификация проверяет, соответствует ли реализованный дизайн заданным спецификациям. При этом используются как методы моделирования, так и формальные методы на различных уровнях абстракции, от архитектурного уровня до чистых списков на уровне затворов. Однако существующие подходы к верификации слишком медленны и просто не в состоянии справиться с растущими размерами и сложностью интегральных схем (ИС). Моделирование на несколько порядков медленнее, чем реальный кремний. Эмуляция и прототипирование полевых программируемых вентильных матриц (ППВМ) обеспечивают более высокую производительность, но с трудом масштабируются для больших проектов. Формальная верификация может применяться в определенных ситуациях, например, для отдельных арифметических блоков или протоколов, но сталкивается с аналогичными проблемами масштабируемости для полной верификации на уровне кристалла. В результате "трудные" и зачастую критические недостатки (баги) конструкции часто ускользают от предкремниевой верификации. Ошибки проектирования можно классифицировать следующим образом:

логические ошибки, которые вызваны ошибками (логического) проектирования;
электрические ошибки, которые вызваны взаимодействием между дизайном и его "электрическим" состоянием.
Существующая предкремниевая верификация недостаточна для устранения "сложных" логических ошибок. Она также не позволяет адекватно устранить электрические ошибки, которые появляются только после изготовления ИС.
###Вопрос 2: Почему важна посткремниевая проверка и с какими проблемами она сталкивается?
Растущее число ошибок проектирования, которые не поддаются докремниевой верификации, означает, что для их обнаружения и устранения все большее значение приобретает посткремниевая валидация изготовленных ИС в реальных системных средах. Эти проблемы еще более возрастают с замедлением масштабирования КМОП кремния (Деннард), поскольку ИС включают в себя огромную сложность конструкции (несколько процессорных ядер, ускорители, неосновные компоненты, управление питанием, тепловыделением и надежностью) для достижения целевых показателей производительности и энергоэффективности.
Для выявления ошибок в производимых ИС используются различные тесты (тесты случайных инструкций, тесты, ориентированные на конкретную архитектуру, трассировка инструкций и приложения для конечных пользователей). Скоростные тесты, выполняемые на кремнии, на порядки быстрее, чем симуляции, используемые при предварительной проверке кремния. Таким образом, можно выполнить большое количество тестов. Однако метрики покрытия для тестов после кремниевой верификации остаются нерешенной проблемой. Для производственных тестов существуют различные хорошо зарекомендовавшие себя метрики покрытия тестов (например, покрытие одиночных застреваний). Эти метрики экспериментально доказали свою эффективность в обнаружении производственных дефектов. Такие метрики, как покрытие кода и покрытие утверждений, используются во время предкремниевой проверки, но они менее стандартизированы. Для посткремниевой проверки метрики покрытия находятся в зачаточном состоянии и являются весьма сложными (отчасти из-за очень ограниченной контролируемости и наблюдаемости традиционных тестов посткремниевой проверки).
Простого обнаружения ошибки во время посткремниевой проверки также недостаточно. После обнаружения ошибки посткремниевая локализация ошибки направлена на определение трассировки ошибки (последовательности входов, например, инструкций, которые активируют и обнаруживают ошибку) и блока аппаратного дизайна, содержащего ошибку. Существующие практики посткремниевой проверки и отладки в основном носят разовый характер, что приводит к очень высоким затратам. Усилия по локализации ошибок из наблюдаемых системных сбоев (например, тупиков, аварий, ошибок вывода) часто доминируют над общими затратами. На локализацию и отладку одной ошибки могут уйти месяцы ручной работы [1], [2].
###Вопрос 3: Почему существующие методы посткремниевой проверки и отладки недостаточны?
Многие существующие методы основаны на использовании буферов трассировки - небольших запоминающих устройств, которые записывают выбранный набор сигналов, как правило, в течение 1000 тактовых циклов. Простой записи такого количества циклов недостаточно, как объясняется в вопросе 4.
Воспроизведение сбоев (повторное выполнение стимулов, вызвавших сбой, из безошибочного состояния) также очень сложно из-за недетерминированного поведения (прерывания, функции ввода-вывода, взаимодействие между несколькими процессорными ядрами и функции операционной системы, такие как переключение контекста).
Серьезные проблемы возникают и из-за размеров современных проектов. Моделирование на уровне системы происходит на несколько порядков медленнее, чем в реальном кремнии. Применение существующего формального анализа и булевой удовлетворительности для локализации ошибок сильно ограничено размерами конструкции.
Хотя утверждения могут использоваться для посткремниевой проверки и отладки, ручное создание утверждений затруднительно. Создание утверждений, которые могут быть эффективно реализованы в аппаратуре, еще сложнее. При автоматической генерации утверждений их количество часто возрастает, и многие из них неэффективны для выявления ошибок.

###Вопрос 4: Что мы можем сделать, чтобы "по-настоящему" продвинуть посткремниевую проверку и отладку?
Сначала мы должны понять "реальную" проблему: очень большие задержки обнаружения ошибок, как показано в [3]-[6]. Задержка обнаружения ошибок - это время, прошедшее между моментом, когда тест активирует ошибку, и моментом, когда сгенерированная ошибка вызывает наблюдаемый сбой (например, системный сбой, таймаут, тупик, исключение). Задержки обнаружения ошибок для "сложных" багов могут превышать миллионы и даже миллиарды тактов [4], [5]. Отследить столь отдаленные моменты в работе системы, особенно в современных сложных SoC, крайне сложно, что быстро делает существующие методы неэффективными.

###Вопрос 5: Как вы преодолеваете длительные задержки обнаружения ошибок?
Наша предыдущая разработка, Quick Error Detection (QED), очень эффективна для быстрого обнаружения логических и электрических ошибок в процессорных ядрах, неосновных компонентах, ускорителях и компонентах, связанных с функциями управления питанием [3]-[7]. QED значительно сокращает время обнаружения ошибок на несколько порядков. Поскольку ошибки обнаруживаются гораздо быстрее, QED одновременно улучшает покрытие ошибок.
QED состоит из набора преобразований, которые систематически преобразуют широкий спектр существующих тестов (называемых исходными тестами) в новые тесты семейства QED [3], [4]. Преобразования QED также могут быть полностью реализованы в программном обеспечении и, следовательно, легко применимы к существующим ИС. Дополнение QED аппаратными средствами (например, [6] и [7]) может дополнительно улучшить задержку обнаружения ошибок, покрытие и время выполнения тестов.
К программным преобразованиям QED относятся обнаружение ошибок с помощью дублирования инструкций для проверки (EDDI-V), проверка потока управления с помощью программных сигнатур для проверки (CFCSS-V), отслеживание потока управления с помощью программных сигнатур для проверки (CFTSS-V), а также проактивная загрузка и проверка (PLC), о чем подробно говорится в [3] и [4]. Ниже мы приводим примеры EDDI-V и PLC.
EDDI-V устраняет ошибки внутри процессорных ядер, часто сверяя результаты выполнения оригинальных инструкций с результатами дублирования инструкций, созданных EDDI-V. Сначала регистры и память делятся на две половины2 , по одной для оригинальных и дублированных инструкций. Для каждой инструкции загрузки, хранения, арифметической, логической, сдвига или перемещения в оригинальном тесте EDDI-V создает дублирующую инструкцию, которая выполняет ту же операцию, используя дублирующие регистры и память. Оба потока команд выполняются в одном и том же порядке, но переплетаются между собой. Чтобы сравнить промежуточные результаты обоих потоков инструкций, преобразование вставляет частые проверочные инструкции следующего вида:

CMP Ra; Ra0
где Ra и Ra0 - исходный и (соответствующий) дублирующий регистры, соответственно. Несоответствие в любой проверочной инструкции указывает на ошибку (т. е. тест QED не пройден).
Реализации QED могут быть навязчивыми, т. е. преобразование может помешать обнаружению ошибки. Для решения проблемы навязчивости [5] вставка дублированных и проверочных инструкций может контролироваться параметрами Inst min и Inst max , минимальным (максимальным) количеством инструкций из исходного теста, которые выполняются до выполнения любых дублированных или проверочных инструкций.
PLC устраняет ошибки в неосновных компонентах, проактивно выполняя частые загрузки из памяти (через эти неосновные компоненты) и проверяя загруженные значения. Начиная с EDDI-V-трансформированного QED-теста, PLC вставляет операции проактивной загрузки и проверки по всему тесту, который выполняется на всех ядрах и во всех потоках. На рисунке 2a показан код, преобразованный с помощью операций PLC, которые подробно описаны на рисунке 2b. Каждая операция PLC проверяет значения в памяти для выбранного набора переменных (список PLC). Для каждой выбранной переменной операция ПЛК сравнивает значение из памяти, зарезервированной для оригинальных инструкций (адрес A) и дублированных инструкций (адрес A0). Любое несоответствие во время проверки ПЛК (CMP Rt, Rt') указывает на ошибку. Несколько стратегий PLC обсуждаются в [5] и [6].
Мы продемонстрировали эффективность QED на нескольких аппаратных платформах (например, Intel Core i7 SoC), используя "трудные" сценарии ошибок из коммерческих многоядерных SoC [3]-[7]. QED сокращает время обнаружения ошибок на девять порядков (например, с миллиардов тактов до примерно десяти тактов для многоядерной SoC Freescale). Кроме того, QED позволяет увеличить охват ошибок в четыре раза.

###Вопрос 6: В чем разница между QED и символическим QED?
Символический QED [8] основан на принципах QED. Он может использоваться как для предкремниевой верификации, так и для посткремниевой валидации. Для обнаружения и локализации логических ошибок путем анализа RTL-проекта используется проверка модели с ограничениями (Bounded Model Checking, BMC) [9]. Учитывая модель системы и проверяемое свойство, BMC формально анализирует модель, чтобы найти, может ли это свойство быть нарушено за ограниченное число шагов. Если свойство может быть нарушено, то BMC сообщает контрпример с указанием необходимых шагов.
Символический QED использует RTL проекта для модели системы. Для свойства проверяется, существует ли QED-тест, который может не сработать (подробно описано в вопросе 8). Инструмент BMC перебирает пространство всех возможных QED-тестов (в пределах своей границы). В [8] символический QED основан на преобразованиях EDDI-V и PLC; однако он может быть расширен и для CFCSS-V и CFTSS-V.
Символический QED локализует ошибки двумя способами. Если BMC возвращает неудачный QED-тест, то невозможно найти более короткий неудачный QED-тест (с соответствующими QED-преобразованиями), который активирует ту же логическую ошибку [9]. Кроме того, символический QED использует частичные инстанцирования, чтобы помочь локализовать ошибку в различных частях конструкции (вопрос 10).
###Вопрос 7: Каковы ключевые преимущества символического QED?
Символический QED применим к любому дизайну SoC при условии, что он содержит хотя бы одно программируемое процессорное ядро (в целом верное предположение).
Он широко применим для поиска логических ошибок в процессорных ядрах, ускорителях и неосновных компонентах.
Он не требует воспроизведения сбоев или моделирования.
Это полностью автоматизированный подход к локализации логических ошибок, не требующий вмешательства человека.
Для локализации логических ошибок не требуется дополнительного оборудования, что является значительным преимуществом по сравнению с другими методами, которые требуют дополнительных затрат площади (например, для буферов трассировки).
Он не требует утверждений, специфичных для конкретного проекта, и предоставляет очень лаконичное и общее свойство для быстрого обнаружения и локализации логических ошибок.
###Вопрос 8: Как вы создаете формальные свойства для символического QED?
Создание "хороших" свойств для проверки с помощью формальных методов (таких как BMC) - известная сложная задача. Символический QED полностью автоматизирует этот процесс за счет использования универсального свойства (т. е. свойства, которое эффективно для поиска большого класса ошибок, независимо от конкретных аппаратных блоков, присутствующих в SoC), основанного на тестировании QED. Свойство, предоставляемое BMC, является производным от проверки, которая обнаружит ошибку во время QED-тестирования. Инструмент BMC пытается найти контрпример к следующему свойству:

где n - количество регистров, определенных ISA. Здесь (для a 2 f0::n=2 1g) Ra и Ra0 соответствуют регистрам, выделенным для оригинальных и дублированных инструкций, соответственно. Это свойство позволяет выявить ошибки, обнаруженные как тестами EDDI-V, так и PLC QED.

###Вопрос 9: Как создать ограничения на окружающую среду для символического QED?
Если инструмент BMC не накладывает никаких ограничений на свои входы при поиске контрпримера, он может найти контрпримеры, состоящие из недопустимых входов. Следовательно, необходимо добавить ограничения среды (ограничения, запрещающие входы, которые не будут встречаться в реальном развертывании), и это создает еще одну проблему для формального анализа.
В символическом QED добавление экологических ограничений не вызывает затруднений. В частности, инструмент BMC должен рассматривать только те последовательности инструкций, которые соответствуют тестам QED. Мы достигаем этого без обширной ручной работы, требуемой в традиционном формальном анализе, используя два механизма.

Мы ограничиваем входы блока выборки инструкций (каждого процессорного ядра) произвольными, но корректными инструкциями, полученными непосредственно из архитектуры набора инструкций (ISA).
Мы добавляем новый модуль QED в блок выборки инструкций каждого процессорного ядра во время BMC (подробности в [8]). Модуль QED автоматически выполняет преобразование EDDI-V "на лету" для любой входной последовательности, изученной в ходе BMC. Модуль QED используется только в инструменте BMC и не добавляется в готовую ИС; т. е. нет никаких накладных расходов на производительность/площадь/мощность, даже при посткремниевой валидации. Включение инструкций загрузки и хранения позволяет нашему подходу активировать и обнаруживать ошибки как в неосновных компонентах, так и в ядрах процессора. Модуль QED довольно прост и должен быть спроектирован только один раз для данного ISA.
На рисунке 3 показан пример преобразований, выполняемых модулем QED. На рисунке 3a показана последовательность входных инструкций, выбранная инструментом BMC (BMC может выбрать любую последовательность допустимых инструкций). На рисунке 3b показаны фактические инструкции, выполняемые процессором LOAD(A) продублирована как LOAD(A')]. Таким образом, сравнение регистров (с помощью инструмента BMC) эквивалентно проверке ПЛК переменных A и A'. Здесь есть четыре события:

сохранение в A ядром 1;
загрузка из A по ядру 2;
сохранение в A' ядром 1; и
загрузка из A' ядром 2. Как объясняется в [8], чтобы избежать ложных сбоев без использования блокировок, модуль QED гарантирует, что порядок 3) и 4) совпадает с порядком
и 2), даже если несколько ядер загружаются из A и A'.
Начальное архитектурное состояние инструмента BMC также должно быть согласованным с QED, с совпадающими исходными и дублирующими регистрами и ячейками памяти. Это может быть состояние сброса, но время выполнения улучшается до 5× [8], если начальное состояние получено в результате быстрого высокоуровневого моделирования эталона, остановленного, когда все значения QED согласованы.
###Вопрос 10: Как можно масштабировать символический QED для больших проектов?
Основной проблемой BMC является работа с большими проектами, что может значительно замедлить работу инструмента BMC или даже привести к его отказу при загрузке проекта. Однако символический QED не требует анализа всего дизайна за один раз. Ключевое свойство проверок QED заключается в том, что они являются композиционными, т. е. предварительно выполняются для частичных экземпляров конструкции (на локализацию которых требуется много времени (от нескольких дней до нескольких недель). Мы считаем, что экземпляр имеет хотя бы одно процессорное ядро).
Symbolic QED справляется с большими дизайнами путем частичного инстанцирования, используя две техники сокращения дизайна (подробности в [8]). Техника 1 берет все компоненты с несколькими экземплярами и многократно уменьшает их количество в два раза (пока не останется только один Таблица 1 наглядно показывает, что символический QED автолефт). Например, в многоядерной SoC процессорные ядра удаляются до тех пор, пока не останется только одно процессорное ядро. Техника 2 удаляет модуль, если его удаление не приводит к разделению дизайна на два несоединимых компонента. Например, если в конструкции процессорное ядро соединено с кэшем через перемычку, перемычка не удаляется (без удаления кэша). Комбинации и повторения этих двух методов учитываются при создании частичных экземпляров (по крайней мере с одним процессорным ядром) для BMC. Частичные экземпляры могут быть проанализированы инструментом BMC независимо (параллельно).
Мы успешно продемонстрировали эту технику на многоядерном дизайне с 500 миллионами транзисторов в [8].

###Вопрос 11: Какие результаты по символическому QED были опубликованы?
В [8] мы продемонстрировали эффективность символического QED на OpenSPARC T2 SoC (http://www.opensparc.net), открытой версии UltraSPARC T2, 500-миллионной транзисторной SoC. Для BMC мы использовали инструмент Questa Formal компании Mentor Graphics (версия 10.2c_3). Мы смоделировали широкий спектр "сложных" логических ошибок (связанных с процессорными ядрами, неядерными компонентами и функциями управления питанием), которые встречались в различных коммерческих многоядерных SoC. Сложными они считаются потому, что для их локализации требуется много времени (от нескольких дней до нескольких недель). Мы сравнили три подхода к получению трасс активации ошибок: оригинальный эталонный тест (FFT из SPLASH-2 [10]), преобразованный в QED эталонный тест и символический QED с инициализацией BMC в QED-совместимое состояние из эталона.
Таблица 1 наглядно показывает, что символический QED автоматически создает трассировки ошибок на шесть порядков короче, чем традиционные посткремниевые тесты валидации, которые полагаются на проверку конечных результатов, и на пять порядков короче, чем тест QED. На рисунке 4 показано количество компонентов, в которых были локализованы ошибки с помощью символического QED. Каждая ошибка может быть дополнительно локализована по полученной трассировке активации. Наконец, символический QED корректно и автоматически создает короткие трассировки для всех ошибок менее чем за 7 ч, без буферов трассировки или какого-либо другого дополнительного оборудования. Несколько стратегий дальнейшего улучшения времени работы BMC для частичных экземпляров обсуждаются в [8].

###Вопрос 12: Каким образом символический QED является автоматизированным подходом?
Символический QED не требует вмешательства человека (или требует минимального вмешательства). Он не требует ручной генерации формальных свойств или ограничений среды.
(Модуль QED разрабатывается один раз для каждого ISA и автоматически вызывается.) Частичные экземпляры (вопрос 10) также создаются автоматически. При условии, что инструмент BMC настроен на прогон каждой частичной инстанциации, дальнейший ввод данных не требуется.

###Вопрос 13: Ограничивается ли символический QED ошибками внутри процессорных ядер?
Нет, как показано в таблице 1 и в вопросе 8 (более подробная информация приведена в [8]). Мы смоделировали множество сценариев ошибок, абстрагированных от реальных "сложных" ошибок, которые встречаются в коммерческих многоядерных SoC. Среди них были логические ошибки в неосновных компонентах (контроллерах кэша, памяти и сетях межсоединений на кристалле), ошибки, связанные с управлением питанием, и ошибки в ядре процессора. Symbolic QED успешно локализовал все эти сценарии ошибок, смоделированные на OpenSPARC T2 SoC.

###Вопрос 14: Как символический QED может быть использован для посткремниевой проверки и отладки?
Некоторые логические ошибки бывает очень сложно активировать, поскольку они требуют очень специфического состояния, которое может быть достигнуто только при выполнении множества специфических инструкций. В результате во время предкремниевой верификации символический QED может не обнаружить этот тип ошибок, если он не запускается из достаточно близкого начального состояния; трассировка будет слишком длинной, чтобы инструмент BMC смог ее обнаружить. Однако при посткремниевой проверке тесты QED могут обнаружить эти ошибки. Соответствующие архитектурные состояния (до обнаружения ошибок) могут быть использованы для инициализации инструмента BMC для символического QED, что позволяет генерировать короткие трассы активации ошибок и локализовать их.
Символический QED может быть дополнительно улучшен во время посткремниевой валидации с помощью дополнительного оборудования (1-2 %) для уменьшения размера дизайна, анализируемого инструментом BMC. Это оборудование требует предварительного запуска тестов QED для посткремниевой проверки. В [8] мы ввели небольшие аппаратные структуры - детекторы изменений - для мониторинга сигналов между аппаратными блоками и регистрации изменений в скользящем окне непосредственно предшествующих циклов выполнения (например, за последние 1000 циклов). Когда тест QED обнаруживает ошибку, если на границе неосновного компонента (в течение анализируемого окна выполнения) не наблюдается изменений сигнала, то мы исключаем этот компонент как кандидата, способствующего возникновению ошибки. Это сокращает количество компонентов для анализа инструментом BMC. Короткие задержки обнаружения ошибок в QED (обычно менее 1000 циклов) позволяют использовать небольшое скользящее окно мониторинга, что уменьшает влияние на площадь.
В экспериментах по локализации ошибок с использованием SoC OpenSPARC T2 высокоиспользуемые компоненты (кэш, контроллеры памяти, кроссбар) обычно не могли быть исключены детекторами изменений. Однако периферийные компоненты со спорадической активностью во время посткремниевой валидации (например, модули ввода/вывода) часто могли быть удалены. Для мониторинга последних потребовалось всего 0,98 % площади (по сравнению с 1,86 % для полного дизайна).

###Вопрос 15: Каковы ограничения символического QED?
Обеспечение достаточно малого размера конструкции для анализа инструментом BMC будет оставаться ключевой проблемой при реализации символического QED. Мы продемонстрировали на OpenSPARC T2, как частичное инстанцирование и детекторы изменений (во время постсиликоновой валидации) могут решить эту проблему. Мы активно ищем более крупные проекты для дальнейшего тестирования этих подходов. Выбор хорошего начального состояния - еще одна проблема, особенно когда символический QED используется во время предкремниевой верификации (как обсуждалось в вопросе 14, тесты QED могут помочь в решении этой проблемы во время посткремниевой валидации).

###Вопрос 16: Каковы некоторые из будущих направлений развития символической QED?
Электрические ошибки: Расширение символического QED для локализации электрических ошибок требует двух дополнительных возможностей: модели цифрового воздействия электрических ошибок и эффективной техники записи состояния ИС во время посткремниевой проверки с помощью QED. Формальный анализ захваченной трассировки ошибок может быть использован для локализации электрических ошибок. Вопрос использования символического QED для выявления ошибок производительности (ошибок проектирования, которые могут повлиять на производительность ИС при сохранении корректной логической функциональности) остается открытым.
Верификация и отладка программного обеспечения: Как продемонстрировано в [7], гибридный QED (H-QED) быстро обнаруживает ошибки в программах на C/C++, соответствующих высокоуровневым описаниям дизайна аппаратных ускорителей (в дополнение к электрическим ошибкам в аппаратных реализациях). H-QED улучшает латентность обнаружения ошибок на два порядка, а охват обнаружения ошибок - на 3×. Поскольку ошибки на уровне C/C++ были успешно обнаружены с помощью H-QED, подходы символического QED могут быть использованы для общей верификации программного обеспечения.
Аналоговые/смешанные сигнальные блоки: Частичное инстанцирование в символическом QED (вопрос 10) позволяет опускать аналоговые/смешанные сигнальные блоки по мере необходимости. Если ошибка не локализована в цифровых блоках, это является сильным доказательством того, что она происходит из аналоговых/смешанных сигнальных блоков. Если существуют цифровые модели аналоговых/смешанных сигнальных блоков (например, в [11]), то символический QED можно использовать и для этих блоков.
Полная локализация неисправностей на уровне системы: Символьная QED вместе с QED потенциально может обеспечить полную локализацию неисправностей на уровне системы в крупномасштабных системах, состоящих из нескольких ИС. Это очень сложная задача, как объясняется в [12]. После того как тесты QED выявят некорректные ИС в системе, символический QED может быть использован для локализации и выявления первопричины неисправностей в этих ИС.
Диагностика производственных дефектов в ходе функционального тестирования и тестирования на уровне системы: Функциональные тесты и тесты системного уровня обычно дополняют сканирующие тесты для выявления производственных дефектов в ИС. Однако диагностировать производственные дефекты по отказам функциональных тестов/тестов системного уровня крайне сложно. Диагностика дефектов важна по нескольким причинам, в том числе для повышения производительности, улучшения качества тестирования и повышения надежности ИС. Сочетание QED и символического QED вместе с моделями дефектов, используемыми для производственного тестирования, может обеспечить эффективную диагностику дефектов во время функционального тестирования и тестирования на системном уровне.